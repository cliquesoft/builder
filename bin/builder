#!/bin/sh
# builder	a small script to build software for Linux distros
#
# Created	2017/07/08 by Dave Henderson (support@cliquesoft.org)
# Updated	2026/02/12 by Dave Henderson (support@cliquesoft.org)
#
# License	2-clause BSD License
#		https://en.wikipedia.org/wiki/BSD_licenses#2-clause_license_.28.22Simplified_BSD_License.22_or_.22FreeBSD_License.22.29
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the appropriate Cliquesoft License for details.
#
# NOTES
# - http://forum.tinycorelinux.net/index.php?topic=18682.0
# - Call this script from inside the directory containing the source code
# - The types of packages produced:
# 	bin	binaries
# 	dev	development
# 	doc	documentation
#	drv	drivers
#	gir	GObject
# 	lib	libraries
# 	loc	locales
#	src	source
# - List 'cmake' options https://stackoverflow.com/questions/16851084/how-to-list-all-cmake-build-options-and-their-default-values




# DEFAULT VARIABLE DEFINITIONS

export DEBUG=0							# whether or not to show debug output during processing

export DIR_CONF='/etc/builder'					# the location of the configuration for this script	NOTE: this can't be changed in the 'config' file since we have to use this value to find the file itself!
export DIR_DUMP='/tmp/staging'					# the staging location that will be the target to dump compiled programs into for making the various packages
# REMOVED 2026/02/12
#export DIR_INCL='${DIR_CONF}/${NAME}/include'			# this will store the directory structure and files to include in the package (e.g. usr/local/share/applications/foo.desktop, usr/local/tce.installed/foo, ...)
export DIR_INST=''						# the directory where the package contents will reside in the running system; blank=root directory
export DIR_PROF='/var/cache/builder/${NAME}'			# this will store individual compile parameters for each package
# REMOVED 2026/02/12
#export DIR_MODS='${DIR_CONF}/${NAME}/patches'			# this will store any modifications/patches that need to be made to the source code before compiling occurs
export DIR_REPO='/tmp/repo'					# the location that the packaged software will be stored and source code is found (when using '-C dir') - the local software repository
export DIR_TEMP='/tmp/builder'					# the temporary location to store any information and files needed by this script
# REMOVED 2026/02/12
#export DIR_XTRA='${DIR_CONF}/${NAME}/extras'			# this will store any files that are used to compile (e.g. httpd.conf for php); useful when DIRS=TRUE

export DIR_BIN="${DIR_INST}/bin"				# directory locations used with 'DIR_INST' (equilent to PREFIX when 'configuring')
export DIR_ETC="${DIR_INST}/etc"
export DIR_LIB="${DIR_INST}/lib"
export DIR_SBIN="${DIR_INST}/sbin"
export DIR_SHARE="${DIR_INST}/share"
export DIR_VAR="/var"
export DIR_MARKERS="${DIR_INST}/tce.installed"
export DIR_SCRIPTS="${DIR_INST}/etc/init.d"

export PATH_PKGCFG="/usr/local/lib/pkgconfig:/usr/lib/pkgconfig"  # the default PKG_CONFIG_PATH value

export DEP_MAKE_ALL='compiletc squashfs_tools rsync find_utils'	# compile-time deps list for all projects (e.g. compiletc, mksquashfs-tools, ...)
export DEP_MAKE_PAK=''						# compile-time deps list for the current project

export EXT_BLDR='.${PACK}.all.bldr'				# [tgz file] package builder profile
export EXT_CODE='.${PACK}.all.code'				# [tgz file] package source code
export EXT_DEPS='.${PACK}.${ARCH}.deps'				# [text file] package dependency list
export EXT_HASH='.${PACK}.${ARCH}.hash'				# [text file] package validation hash
export EXT_INFO='.${PACK}.${ARCH}.info'				# [text file] package information
export EXT_LIST='.${PACK}.${ARCH}.list'				# [text file] package manifest list
export EXT_MAKE='.${PACK}.${ARCH}.make'				# [text file] package make commands
export EXT_SOFT='.${PACK}.${ARCH}.soft'				# [mksquashfs file] packaged compiled software

export OWN_USER='root'						# the ownership to apply to files of the package
export OWN_GROUP='staff'

export PRM_DIRS='775'						# the permissions to apply to directories of the package
export PRM_FILES='664'						# the permissions to apply to all files of the package
export PRM_EXECS='755'						# the permissions to apply to all executables in /bin, /sbin, etc and also the libraries

export URL_CODE=''						# the developer URL used to obtain the package source code (set in a package config file)
export URL_INFO='http://repo.cliquesoft.org/vanilla/1.1/${NAME}/${NAME}${EXT_INFO}'		# the .info file URL used to obtain the package source code (set in builder config file)
export URL_REPO='http://repo.cliquesoft.org/vanilla/1.1/${NAME}/${NAME}${EXT_CODE}'		# the distro repo URL used to obtain the package source code (set in builder config file)
export GIT_REPO=''						# the online git repo that can be cloned (set in a package config file)

export SPM_ALL='$SUDO pax -i $DEP_MAKE_ALL'			# the software package manager command to install compile-time dependencies (overall)
export SPM_PACK='$SUDO pax -i $DEP_MAKE_PAK'			# the software package manager command to install compile-time dependencies (package specific)
export SPM_MAKE='$SUDO pax -m $NAME ./'				# the software package manager command to make a package from the compiled software by this script
export SPM_UNLD='$SUDO pax -u $DEP_MAKE_PAK'			# the software package manager command to unload compile-time dependencies (to keep the environment clean)

export LOG='/var/log/builder - ${NAME}.log'			# the log file for compile output (contains both stdout and stderr)
export SUDO=''							# whether or not 'sudo' should be called for all commands after the 'ownership and permissions' have been set (if they are restrictive enough to warrant it)

# set default compile flags (which can be overwritten with DIR_CONF or individual DIR_PROF configs)
# NOTE: additional flags can also be set in this variable as well (e.g. LC_CTYPE, QT_IM_MODULE, GTK_IM_MODULE, ...)
FLAG_A32="export CFLAGS='-march=armv6zk -mtune=arm1176jzf-s -mfpu=vfp -Os -pipe'
	export CXXFLAGS='-march=armv6zk -mtune=arm1176jzf-s -mfpu=vfp -Os -pipe'
	export LDFLAGS='-Wl,-O1'
	export PKG_CONFIG_PATH='${PATH_PKGCFG}'"		# ARM 32bit
FLAG_A64="export CFLAGS='-march=armv8-a+crc -mtune=cortex-a53 -Os -pipe'
	export CXXFLAGS='-march=armv8-a+crc -mtune=cortex-a53 -Os -pipe'
	export LDFLAGS='-Wl,-O1'
	export PKG_CONFIG_PATH='${PATH_PKGCFG}'"		# ARM 64bit
FLAG_I32="export CFLAGS='-march=i486 -mtune=i686 -Os -pipe'
	export CXXFLAGS='-march=i486 -mtune=i686 -Os -pipe'
	export LDFLAGS='-Wl,-O1'
	export PKG_CONFIG_PATH='${PATH_PKGCFG}'"		# Intel/AMD 32bit
FLAG_I64="export CFLAGS='-mtune=generic -Os -pipe'
	export CXXFLAGS='-mtune=generic -Os -pipe'
	export LDFLAGS='-Wl,-O1'
	export PKG_CONFIG_PATH='${PATH_PKGCFG}'"		# Intel/AMD 64bit
FLAG_R32="export CFLAGS='-march=armv6zk -mtune=arm1176jzf-s -mfpu=vfp -Os -pipe'
	export CXXFLAGS='-march=armv6zk -mtune=arm1176jzf-s -mfpu=vfp -Os -pipe'
	export LDFLAGS='-Wl,-O1'
	export PKG_CONFIG_PATH='${PATH_PKGCFG}'"		# RPi 32bit
FLAG_R64="export CFLAGS='-march=armv8-a+crc -mtune=cortex-a53 -Os -pipe'
	export CXXFLAGS='-march=armv8-a+crc -mtune=cortex-a53 -Os -pipe'
	export LDFLAGS='-Wl,-O1'
	export PKG_CONFIG_PATH='${PATH_PKGCFG}'"		# RPi 64bit




# -------------------- DO **NOT** EDIT BELOW THIS LINE --------------------



								# NOTE: This sets defaults on single-pass runs, but also resets the values with multi-pass.
# [system]								Also some variables below are exported so the 'pre' and 'post' scripts can access them.
THIS="$0"							# stores this script for multi-pass calls
CPU='a32,a64,i32,i64,r32,r64'					# the CPU architectures that you wish to compile for (comma separated): ARM 32/64bit, Intel/AMD 32/64bit, RPi 32/64big
CWDL="$(pwd)"							# stores the current working directory location
EXPORTS=''							# defines which compile flags to export for the desired CPU architecture
export PACK=''							# the type of package being made (e.g. bin, dev, doc, ...)
SORT=''								# indicates we need to sort the package contents on this pass
TEMP=''								# stores a temporary value

# [names]
export NAME=''							# the name of the package being compiled

# [actions]
BUILD=''							# if we need to build a software package
# UPDATED 2026/02/12
#EXAMPLE=''							# if we need to generate an example .info file and exit
INSTALL=''							# indicates we need to install the builder profile
# UPDATED 2026/02/12
#export NOPK=''							# indicates that NO packaging should take place, only a software compile
COMPILE=''							# indicates that NO packaging should take place, only a software compile
PROFILE=''							# create a builder profile
REPACK=''							# indicates that we just need to repack the software since something in the 'include' directories changed
TEMPLATE=''							# creates a blank builder profile template and exit

# [options]
export ARCH=''							# the current CPU architecture being compiled (e.g. i32, i64, ...)
DIRS=''								# indicates we need to package using directory names instead of just a directory named NAME
INFOFILE=''							# stores the info file to download/use to obtain the software
export PASS=''							# the number of passes to make during compile (blank disables)
PATCH=TRUE							# indicates we need to apply patches to the source code
SKIP=''								# indicates we need to skip packaging until the final pass
SINGLE=''							# indicates all files need to be placed in a single package
TRIM=''								# any part of the name to remove when building the package
TYPE=''								# the type of compile being performed (e.g. autogen, bootstrap, ...)
WGET=''								# indicates that we need to download the source code file; valid values: local, private, public
UNLOAD=''							# indicates we need to unload the packages afterwards - regardless of success or failure

# [config]
CHECK=0								# indicates that the 'make check' step is requested to be made during compile
CLEAN=0								# indicates that the 'make clean' step is necessary (mostly for multi-run compiles)		NOTE: passing a '2' value performs a distclean
CONF=1								# indicates that the 'configure' step needs to be made during compile
PROP=0								# indicates that the 'make mrproper' step is necessary (mostly for multi-run compiles)
TEST=0								# indicates that the 'make test' step is requested to be made during compile
CODE=''								# when compiling multiple softwares with a single builder profile (e.g. alsa-lib, alsa-utils), this value uniquely identifies the package per pass (e.g. config.1 > CODE='alsa-lib'; config.2 > CODE='alsa-utils')

# UPDATED 2026/02/12
#COMPILE=''							# used when TYPE='custom'
CUSTOM=''							# used when TYPE='custom'

CFG_BIN=""							# DIR_INST/bin	directory locations used with 'configure'
CFG_DATA=""							# DIR_INST/usr/share
CFG_DATAROOT=""							# CFG_DATA
CFG_DOC=""							# CFG_DATA/doc/NAME
CFG_DVI=""							# CFG_DOC
CFG_HTML=""							# CFG_DOC
CFG_INCLUDE=""							# DIR_INST/usr/local/include
CFG_INFO=""							# CFG_DATA/info
CFG_LIB=""							# DIR_INST/lib
CFG_LIBEXEC=""							# DIR_INST/libexec
CFG_LOCALE=""							# CFG_DATA/locale
CFG_LOCALSTATE=""						# DIR_INST/var
CFG_MAN=""							# CFG_DATA/man
CFG_OLDINCLUDE=""						# /usr/include
CFG_PDF=""							# CFG_DOC
CFG_PS=""							# CFG_DOC
CFG_SBIN=""							# DIR_INST/sbin
CFG_SHAREDSTATE=""						# DIR_INST/com
CFG_SYSCONFIG=""						# DIR_INST/etc
CFG_MISC=""							# a standardized extra variable that can be used per project (e.g. mplayer codecs)	NOTE: this one will need to include the switch as well (e.g. '--codec-dir=...')

DEP_EXEC_ALL=''
DEP_EXEC_BIN=''							# run-time deps list for each package type
DEP_EXEC_DEV=''
DEP_EXEC_DOC=''
DEP_EXEC_DRV=''
DEP_EXEC_GIR=''
DEP_EXEC_LIB=''
DEP_EXEC_LOC=''
DEP_MAKE_PAK=''							# compile-time deps list for a specific project

FLAG_CONF=''							# the flags to pass to the 'configure' script or 'cmake'
FLAG_INST=''							# the flags to pass to the 'make install' call
FLAG_MAKE=''							# the flags to pass to the 'make' call




# -------------------------------------------------------------------------




# DEFINE BUILT-IN FUNCTIONS FOR EXPORT




# DEFINE BUILT-IN FUNCTIONS FOR INTERNAL USE

# Syntax: stop TYPE [EXIT]
# Exits gracefully by cleaning up the desired parts of the file system after a failed build
# TYPE	the type of cleanup to perform: failed, clean (for multi-pass), proper
# EXIT	if the function should exit this script afterwards: 0, 1 (default)
stop() {
	[ "$1" = 'failed' ] && echo "ERROR: This step failed to complete, check the log for details."

	[ "$DEP_MAKE_PAK" ] && [ "$SPM_UNLD" ] && [ "$UNLOAD" ] && {
		echo -e "\nUnloading compile-time dependencies..." | tee -a "$LOG"
		eval $SPM_UNLD 2>>"$LOG"
	}

	if [ "$1" = 'failed' ]; then
		rm -Rf "${DIR_TEMP:?}/${NAME}.pass" 2>>"$LOG"	# we just delete this file to prevent issues
		exit 1
	elif [ "$1" = 'clean' ]; then
		rm -Rf "${DIR_DUMP:?}/${NAME}/"* 2>>"$LOG"	# NOTE: the ':?' prevents the expression from evaluating to 'rm /*'
		rm -Rf "${DIR_TEMP:?}/${NAME}.pass" 2>>"$LOG"
		( [ ! "$2" ] || [ $2 -eq 1 ] ) && exit 1
	elif [ "$1" = 'proper' ]; then
		[ ! "$NAMES" ] && NAMES="$NAME"			# if the 'packaging' stage hasn't been reached yet, the only directory that would possibly exist would just be NAME
		for DIR in $NAMES; do
			rm -Rf "${DIR_TEMP:?}/${DIR}" 2>>"$LOG"
			rm -Rf "${DIR_TEMP:?}/${DIR}.build" 2>>"$LOG"
			rm -Rf "${DIR_TEMP:?}/${DIR}.pass" 2>>"$LOG"
			rm -Rf "${DIR_TEMP:?}/${DIR}.sort" 2>>"$LOG"

			[ -d "${DIR_DUMP:?}/${DIR}" ] && rm -Rf "${DIR_DUMP:?}/${DIR}" 2>>"$LOG" # since the directory might not be renamed to DIR_DUMP.bin yet
			for PACK in bin dev doc drv gir lib loc; do
				if [ -d "${DIR_DUMP:?}/${DIR}.${PACK}" ]; then
					rm -Rf "${DIR_DUMP:?}/${DIR}.${PACK}" 2>>"$LOG" || {
						echo "ERROR: This step failed to complete, check the log for details."
						exit 1
					}
				fi
			done
		done
		[ -x "${DIR_PROF}/cleanup" ] && "${DIR_PROF}/cleanup" 2>>"$LOG"			# if a cleanup script has been included, execute it as well!
		( [ ! "$2" ] || [ $2 -eq 1 ] ) && exit 0
	fi
}




# Syntax: package
# (Re-)packages the compiled software
package() {
	# PRE-PACKAGE SORTING

	TEMP=''
	if [ "$SINGLE" ] && ( [ "$SORT" ] || [ ! "$PASS" ] ); then				# if we do NOT need separate packages -AND- (were instructed to sort on this pass -OR- there is only one pass), then...
		# store the package names that need to be processed (either NAME or directory names)
		[ ! "$DIRS" ] && [ ! "$TRIM" ] && NAMES="$NAME"					# if we are not packaging all the directories found in DIR_DUMP -AND- no trimming should be applied, then just store the name of the requested package
		[ ! "$DIRS" ] && [ "$TRIM" ] && {						# same as above, but with trimming any portion of the name along with the actual renaming of the directory to match
			NAMES="$(echo "$NAME" | sed "s/${TRIM}//")"
			mv "$NAME" "$NAMES" 2>>"$LOG"
		}
		[ "$DIRS" ] && NAMES="$(ls -1 "$DIR_DUMP")"					# otherwise, we are so store all the names of the directories before we create the .bin, .dev, .drv, etc related directories

		for DIR in $NAMES; do
			# strip the debug symbols from the just-compiled software		  https://superuser.com/questions/236601/how-do-i-execute-multiple-commands-when-using-find
			find . -type f -executable \( -not -name \*.la -a -not -name \*.a \) -exec /bin/sh -c 'file -b --mime-type {} | grep -q application && strip --strip-unneeded {}' \;
		done

		[ ! -d "${DIR}.all" ] && mkdir "${DIR}.all" 2>>"$LOG"				# create a directory for all the files of a single package
		cp -dpR "${DIR}/*" "${DIR}.all" 2>>"$LOG"					# copy all the compiled software into that directory
		TEMP='all'									# store the directory to all files in a single package
	elif [ ! "$SINGLE" ] && ( [ "$SORT" ] || [ ! "$PASS" ] ); then				# if we need separate packages -AND- (were instructed to sort on this pass -OR- there is only one pass), then...
		cd "${DIR_DUMP}" || {								# change into the temp packaging directory
			echo "Calling: cd \"$DIR_DUMP\"" >>"$LOG"
			echo "ERROR: The staging location directory (DIR_DUMP) could not be entered." >>"$LOG"
			stop failed
		}

		# generate the sort script for the 'find' calls below
		echo '#!/bin/sh' >"${DIR_TEMP}/${NAME}.sort"
		echo 'TEMP="${2#*/}"' >>"${DIR_TEMP}/${NAME}.sort"				# strip the first directory (source) of the path from the variable value
		echo "cd \"$NAME\"" >>"${DIR_TEMP}/${NAME}.sort"				# cd into the parent directory of the source so it does not get copied as well
		echo 'rsync -a -R --devices --specials --remove-source-files "${TEMP}" "../$1"' >>"${DIR_TEMP}/${NAME}.sort"
		chmod 775 "${DIR_TEMP}/${NAME}.sort"

		# store the package names that need to be processed (either NAME or directory names)
		[ ! "$DIRS" ] && [ ! "$TRIM" ] && NAMES="$NAME"					# if we are not packaging all the directories found in DIR_DUMP -AND- no trimming should be applied, then just store the name of the requested package
		[ ! "$DIRS" ] && [ "$TRIM" ] && {						# same as above, but with trimming any portion of the name along with the actual renaming of the directory to match
			NAMES="$(echo "$NAME" | sed "s/${TRIM}//")"
			mv "$NAME" "$NAMES" 2>>"$LOG"
		}
		[ "$DIRS" ] && NAMES="$(ls -1 "$DIR_DUMP")"					# otherwise, we are so store all the names of the directories before we create the .bin, .dev, .drv, etc related directories

		echo -e "\nSeparating into various packages..." | tee -a "$LOG"
		for DIR in $NAMES; do
			# strip the debug symbols from the just-compiled software		  https://superuser.com/questions/236601/how-do-i-execute-multiple-commands-when-using-find
			find . -type f -executable \( -not -name \*.la -a -not -name \*.a \) -exec /bin/sh -c 'file -b --mime-type {} | grep -q application && strip --strip-unneeded {}' \;

			# create all the directories to split the package contents into
			[ ! -d "${DIR}.dev" ] && mkdir "${DIR}.dev" 2>>"$LOG"
			[ ! -d "${DIR}.doc" ] && mkdir "${DIR}.doc" 2>>"$LOG"
			[ ! -d "${DIR}.drv" ] && mkdir "${DIR}.drv" 2>>"$LOG"
			[ ! -d "${DIR}.gir" ] && mkdir "${DIR}.gir" 2>>"$LOG"
			[ ! -d "${DIR}.lib" ] && mkdir "${DIR}.lib" 2>>"$LOG"
			[ ! -d "${DIR}.loc" ] && mkdir "${DIR}.loc" 2>>"$LOG"

			# split the package contents into bin, doc, dev, lib, ...
			# https://unix.stackexchange.com/questions/154818/how-to-integrate-mv-command-after-find-command
			# https://superuser.com/questions/596876/how-to-find-a-file-and-move-it-into-the-directory-it-was-found-in
			# https://unix.stackexchange.com/questions/46322/how-can-i-recursively-delete-empty-directories-in-my-home-directory
			# https://superuser.com/questions/236601/how-do-i-execute-multiple-commands-when-using-find
			find "${DIR}${DIR_INST}/share/doc" -not -type d -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.doc\" '{}'" \; 2>/dev/null
			find "${DIR}${DIR_INST}/share/info" -not -type d -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.doc\" '{}'" \; 2>/dev/null
			find "${DIR}${DIR_INST}/share/man" -not -type d -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.doc\" '{}'" \; 2>/dev/null
			find "${DIR}${DIR_INST}/share/gtk-doc" -not -type d -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.doc\" '{}'" \; 2>/dev/null
			find "$DIR" -not -type d \( -name \*.c -o -name \*.c++ -o -name \*.h -o -name \*.hh -o -name \*.hpp -o -name \*.hxx -o -name \*.h++ -o -name \*.pc -o -name \*.la -o -name \*.a -o -name \*.m4 -o -name \*.vapi \) -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.dev\" '{}'" \; 2>/dev/null
			find "${DIR}${DIR_INST}/lib/cmake" -not -type d -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.dev\" '{}'" \; 2>/dev/null		# NOTE: this was moved below the 'doc' since some packages (xslt) have html documentation ending in .c that doesn't need to go in the 'dev' package
			find "$DIR" -not -type d -name Makefile.\* -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.dev\" '{}'" \; 2>/dev/null
			find "$DIR" -type f -name \*.ko.gz -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.drv\" '{}'" \; 2>/dev/null
			find "$DIR" -type f \( -name \*.typelib -o -name \*.gir \) -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.gir\" '{}'" \; 2>/dev/null
			find "${DIR}${DIR_INST}/lib/" -not -type d -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.lib\" '{}'" \; 2>/dev/null
			find "${DIR}${DIR_INST}/lib64/" -not -type d -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.lib\" '{}'" \; 2>/dev/null
# LEFT OFF - do the libexec files also need to go in the 'lib' package?
			find "$DIR" -type f -name \*.mo -exec /bin/sh -c "\"${DIR_TEMP}/${NAME}.sort\" \"${DIR}.loc\" '{}'" \; 2>/dev/null

			# get rid of all empty directories from the 'bin' package
			find "$DIR" -type d -empty -delete 2>/dev/null

			# anything left should be binaries, so rename the directory
			[ -e "$DIR" ] && mv "$DIR" "${DIR}.bin"					# adjust the name so it can be included in the 'for' loop below		NOTE: test first incase the package only contains libs (which will erase this directory on the line above)
		done

		TEMP='bin dev doc drv gir lib loc'						# store all the directories the files were separated into
	fi

	# NOTE: we should only apply ownership and permissions on the final pass!!!
	if [ ! "$PASS" ] || [ $PASS -eq $(cat "${DIR_TEMP}/${NAME}.pass" | sed 's/|.*//') ]; then							# if '-p' wasn't passed -OR- it was -and- we are on the last pass, then...
		echo -e "\nApplying ownership and permissions..." | tee -a "$LOG"	# NOTE: this has to come below the 'post' script incase that is what handles the 'install' portion when TYPE=custom (e.g. FXwm)
		for DIR in $NAMES; do
			for PACK in $TEMP; do
				[ ! -d "${DIR_DUMP}/${DIR}.${PACK}" ] && continue	# if a directory is missing then there's no reason to process something that doesn't exist!

				cd "${DIR_DUMP}/${DIR}.${PACK}" 2>>"$LOG" || {		# change into the temp packaging directory
					echo "Calling: cd \"${DIR_DUMP}/${DIR}.${PACK}\"" >>"$LOG"
					echo "ERROR: The staging location directory (DIR_DUMP) could not be entered." >>"$LOG"
					stop failed
				}
				find . \( -type f -exec chmod $PRM_FILES {} \; \) , \( -type d -exec chmod $PRM_DIRS {} \; \)				# update the permissions of all the package contents	https://stackoverflow.com/questions/3740152/how-do-i-set-chmod-for-a-folder-and-all-of-its-subfolders-and-files-in-linux-ubu
				find ".${DIR_MARKERS}" -exec chmod $PRM_EXECS {} \; 2>/dev/null
				find ".${DIR_SCRIPTS}" -exec chmod $PRM_EXECS {} \; 2>/dev/null
				find ".${DIR_INST}/lib/" \( -not -type d -a -not -name \*.a \) -exec chmod $PRM_EXECS {} \; 2>/dev/null			# update the permissions of all the libraries
				find ".${DIR_INST}/lib64/" \( -not -type d -a -not -name \*.a \) -exec chmod $PRM_EXECS {} \; 2>/dev/null
				find ".${DIR_INST}/libexec/" -not -type d -exec chmod $PRM_EXECS {} \; 2>/dev/null					# update the permissions of lib executables		https://www.redhat.com/archives/rpm-list/2004-February/msg00027.html  https://unix.stackexchange.com/questions/74646/difference-between-lib-lib32-lib64-libx32-and-libexec
				chmod $PRM_EXECS bin/* sbin/* usr/bin/* usr/sbin/* usr/local/bin/* usr/local/sbin/* 2>/dev/null				# update these directory contents to be executable
				eval $SUDO chown -hR ${OWN_USER}:${OWN_GROUP} ./* >>"$LOG" 2>&1								# update the ownership of all the package contents
			done
		done

		[ $DEBUG -gt 0 ] && {
			echo -n "   DEBUG: Check the DIR_DUMP and DIR_TEMP directories and press any key... "
			read
		}
	fi




	# CREATE EACH PACKAGE

	if [ ! "$SKIP" ] || ( [ "$SKIP" ] && [ $PASS -eq $(cat "${DIR_TEMP}/${NAME}.pass" | sed 's/|.*//') ] ); then		# if '-F' wasn't passed -OR- it was -and- we are on the last pass, then exit this function
		return 0
	fi

	cd "${DIR_DUMP}" 2>>"$LOG" || {								# change into the temp packaging directory
		echo "Calling: cd \"$DIR_DUMP\"" >>"$LOG"
		echo "ERROR: The staging location directory (DIR_DUMP) could not be entered." >>"$LOG"
		stop failed
	}

	[ ! "$PASS" ] && [ -x "${DIR_PROF}/pre.package" ] && {					# execute any existing final script (for single-pass; multi-pass is next block)
		echo -e "\nExecuting the 'pre.package' script..." | tee -a "$LOG"
		"${DIR_PROF}/pre.package" 2>>"$LOG" || stop failed
	}
	[ "$PASS" ] && [ -x "${DIR_PROF}/pre.package.${PASS}" ] && {
		echo -e "\nExecuting the 'pre.package' script..." | tee -a "$LOG"
		"${DIR_PROF}/pre.package.${PASS}" 2>>"$LOG" || stop failed
	}

	# store the package names that need to be processed (either NAME or directory names)	  NOTE: this has to be performed again incase additional directories were added/removed via a 'pre.package' script
	[ ! "$DIRS" ] && [ ! "$TRIM" ] && NAMES="$NAME"					# if we are not packaging all the directories found in DIR_DUMP -AND- no trimming should be applied, then just store the name of the requested package
	[ ! "$DIRS" ] && [ "$TRIM" ] && {						# same as above, but with trimming any portion of the name along with the actual renaming of the directory to match
		NAMES="$(echo "$NAME" | sed "s/${TRIM}//")"
		eval $SUDO mv "$NAME" "$NAMES" 2>>"$LOG"
	}
	[ "$DIRS" ] && NAMES="$(ls -1 "$DIR_DUMP" | sed 's/\.[^\.]*$//' | sort -u)"	# otherwise, we are so store all the names of the directories before we create the .bin, .dev, .drv, etc related directories
												# NOTE: list all contents | non-greedy sed to remove extension (e.g. .bin) | sort to remove duplicates
	echo -e "\nCreating the various packages..." | tee -a "$LOG"
	for DIR in $NAMES; do								# NOTE: the DIR variable will contain directory names, or the actual names of the packages - depending on configuration
		for PACK in $TEMP; do
			[ ! -d "${DIR}.${PACK}" ] && continue				# if a 'pre/post' script created directories manually, then some may be missing so no reason to process something that doesn't exist!

			eval TMP_DEPS="$EXT_DEPS"					# update these values if variables were included in their name
			eval TMP_HASH="$EXT_HASH"
			eval TMP_INFO="$EXT_INFO"
			eval TMP_LIST="$EXT_LIST"
			eval TMP_SOFT="$EXT_SOFT"

			eval URL_TEMP="${URL_INFO//NAME/DIR}"

			[ $DEBUG -gt 0 ] && echo "   DEBUG (Pak Info): $DIR $PACK, ${DIR}${TMP_SOFT}"
			[ $DEBUG -gt 0 ] && echo "   DEBUG (URL Info): $URL_TEMP"

			[ "$(ls -1 "${DIR}.${PACK}" | head -1)" = '' ] && continue	# if there are no contents for the iterated package, then no reason to execute the below segment
			echo "   ${DIR} [${PACK}]"
			echo -e "\n\n   ----- ${DIR} ${PACK} -----\n\n" >>"$LOG"
			eval $SPM_MAKE							# NOTE: we use a variable so any package manager can create a native package for their distro
			case "$PACK" in											# create the dependency list
				'all') [ "$DEP_EXEC_ALL" ] && echo -e "$DEP_EXEC_ALL" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
				'bin') [ "$DEP_EXEC_BIN" ] && echo -e "$DEP_EXEC_BIN" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
				'dev') [ "$DEP_EXEC_DEV" ] && echo -e "$DEP_EXEC_DEV" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
				'doc') [ "$DEP_EXEC_DOC" ] && echo -e "$DEP_EXEC_DOC" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
				'drv') [ "$DEP_EXEC_DRV" ] && echo -e "$DEP_EXEC_DRV" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
				'gir') [ "$DEP_EXEC_GIR" ] && echo -e "$DEP_EXEC_GIR" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
				'lib') [ "$DEP_EXEC_LIB" ] && echo -e "$DEP_EXEC_LIB" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
				'loc') [ "$DEP_EXEC_LOC" ] && echo -e "$DEP_EXEC_LOC" | tr ' ' '\n' >"${DIR_REPO}/${DIR}${TMP_DEPS}" ;;
			esac
			[ ! "$URL_INFO" ] && echo "   WARN: Don't forget to create the .info file for the package!" | tee -a "$LOG"
			[ "$URL_INFO" ] && {
				echo "   WARN: Don't forget to update the .info file for the package!" | tee -a "$LOG"
				eval wget "$URL_TEMP" -O "${DIR_REPO}/${DIR}${TMP_INFO}" 2>/dev/null			# download the existing information file
			}

			mv "${DIR}${TMP_SOFT}" "${DIR}${TMP_LIST}" "${DIR}${TMP_HASH}" "$DIR_REPO"			# copy the files into the repo
			echo "   Your package is now available in: ${DIR_REPO}"
		done
	done
	eval $SUDO chown -hR ${USER} * >>"$LOG" 2>&1						# update the ownership of all the package contents to be the current user so we can delete it

	[ ! "$PASS" ] && [ -x "${DIR_PROF}/post.package" ] && {				# execute any existing final script (for single-pass; multi-pass is next line)
		echo -e "\nExecuting the 'post.package' script..." | tee -a "$LOG"
		"${DIR_PROF}/post.package" 2>>"$LOG" || stop failed
	}
	[ "$PASS" ] && [ -x "${DIR_PROF}/post.package.${PASS}" ] && {
		echo -e "\nExecuting the 'post.package' script..." | tee -a "$LOG"
		"${DIR_PROF}/post.package.${PASS}" 2>>"$LOG" || stop failed
	}
}










# LOAD GLOBAL CONFIGURATION

[ -e "${DIR_CONF}/config" ] && . "${DIR_CONF}/config"												# System-wide config, overwriting any default variable values set at the top
[ -e "/usr/local/${DIR_CONF}/config" ] && . "/usr/local/${DIR_CONF}/config"									# ditto as alternate location
[ -e "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config" ] && . "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config"				# ditto as personalized config file - using XSB
[ -e "${HOME}/.${DIR_CONF##*/}/config" ] && . "${HOME}/.${DIR_CONF##*/}/config"									# ditto as personalized config file - using LSB




# LOAD PROJECT CONFIGURATION

[ ! "$PASS" ] && [ -e "${DIR_PROF}/config" ] && . "${DIR_PROF}/config"										# Global package parameters	NOTE: if not doing a multi-pass
[ ! "$PASS" ] && [ -e "/usr/local/${DIR_PROF}/config" ] && . "/usr/local/${DIR_PROF}/config"							# ditto as alternate location
[ ! "$PASS" ] && [ -e "${HOME}/.$(echo "${DIR_PROF}" | tail -c +2)/config" ] && . "${HOME}/.$(echo "${DIR_PROF}" | tail -c +2)/config"		# ditto as personalized config file - using XSB
[ ! "$PASS" ] && [ -e "${HOME}/.${DIR_PROF##*/}/config" ] && . "${HOME}/.${DIR_PROF##*/}/config"						# ditto as personalized config file - using LSB
[ "$PASS" ] && [ -e "${DIR_PROF}/config.${PASS}" ] && . "${DIR_PROF}/config.${PASS}"								# if we are on a multi-pass and a config exists for that pass, then read it in!
[ "$PASS" ] && [ -e "/usr/local/${DIR_PROF}/config.${PASS}" ] && . "/usr/local/${DIR_PROF}/config.${PASS}"
[ "$PASS" ] && [ -e "${HOME}/.$(echo "${DIR_PROF}" | tail -c +2)/config.${PASS}" ] && . "${HOME}/.$(echo "${DIR_PROF}" | tail -c +2)/config.${PASS}"
[ "$PASS" ] && [ -e "${HOME}/.${DIR_PROF##*/}/config.${PASS}" ] && . "${HOME}/.${DIR_PROF##*/}/config.${PASS}"




# LOAD SWITCH DEFAULTS

[ -e "${DIR_CONF}/params" ] && . "${DIR_CONF}/params"												# System-wide config, overwriting any default variable values set at the top
[ -e "/usr/local/${DIR_CONF}/params" ] && . "/usr/local/${DIR_CONF}/params"									# ditto as alternate location
[ -e "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/params" ] && . "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/params"				# ditto as personalized config file - using XSB
[ -e "${HOME}/.${DIR_CONF##*/}/params" ] && . "${HOME}/.${DIR_CONF##*/}/params"									# ditto as personalized config file - using LSB




# PROCESS THE PASSED SWITCHES

if [ "$1" = '' ] || [ "$1" = '--help' ]; then
	echo
	echo " This script is used to build software for Linux repositories using per package"
	echo " configurations to tailor the software specifically for your distro."
	echo
	echo "  Usage:"
	echo "	${THIS##*/} [OPTIONS] ACTION NAME"
	echo
	echo "  Actions:"
	echo "	-b	build a distributable package"
	echo "	-c	compile the software only, no packaging"				# this is so that end users can simply download source code and build locally without having to package anything
	echo "	-d	download the builder profile (uses URL_REPO)"
# UPDATED 2026/02/12
#	echo "	-e	create a package .info file template"
	echo "	-i	install the builder profile"						# installs the builder profile in /etc/builder so it can be used
	echo "	-p	create a builder profile"
	echo "	-r	only re-package software instead of building"				# this will be useful if something in 'DIR_PROF/include' gets updated (e.g. added a .desktop file); this can also sort a single package into multiple (e.g. bin, doc, lib, etc)
	echo "	-t	create a package template: info, profile"
# VER2 - check for updates to software via git or website; also allow this to be setup via cron to automatically check
#	echo "	-u	checks for updated versions of software"
	echo
	echo "	--help		shows this screen"
	echo "	--version	shows the version of this script"
	echo
	echo "  Options:"
	echo "	-A	the CPU architecture to build: ${CPU},all (default)"
	echo "	-C	obtain source code from:"
# DOC NOTE: URL_CODE and GIT_REPO need to go in the config file for the project; URL_INFO and URL_REPO need to be placed in the /etc/builder/config file (with overwrites in the project config file
	echo "			dev(eloper)|dir(ectory)|git(clone)|(distro)repo"		# 'dev' is the official software manufacturer (URL_CODE in config); 'dir' is a local directory (DIR_REPO in config); 'repo' is the distro repo URL (URL_REPO in config); 'git' is the online git repo to clone from (GIT_REPO in config); this is based on the 'git' and 'clone' values in the .info file	WARN: this requires an existing .info file with certain values!
	echo "	-D	package using directories in DIR_DUMP instead of NAME value"		# this is useful if a pre/post script creates multiple packages from a single compile (e.g. php, php-cli, php-fpm, etc)
	echo "	-F	skips packaging until final pass"
# DOC NOTE: this works in conjunction with the -C (except 'dir'), otherwise, it will use the locations from the builder profile
	echo "	-I	downloaded the package info file and use its locations"
	echo "	-N	the number of passes to make when compiling"				# NOTE: this can use per-pass files (e.g. pre.1, pre.2, config.1, etc)
	echo "	-P	prevent patching from occurring"					# this will prevent the patching stage if the patches have already been applied to the source code
	echo "	-R	remove a portion of NAME when packaging; can use regex anchors"		# this is useful for XiniX when compiling something like 'libmount' so it can become 'mount.i32.lib.soft'; this value can use regex anchors [^$]
	echo "	-S	package all contents in a single package - do NOT separate"
	echo "	-T	the compile type to use:"
	echo "			autoconf"
	echo "			autogen"
	echo "			bootstrap"
	echo "			cmake"
	echo "			custom"
	echo "			default (configure, make, make install)"
	echo "			scons"
	echo "	-U	do not unload compilation packages afterwards"				# this is useful for testing the build profile before it works correctly -OR- just to prevent excessive resource usage when building an entire repo
	echo
	echo
	echo "  Build Software Steps:                             [end user/package creator]"
	echo "	1. builder -d NAME (or download the builder profile manually)"
	echo "	3. cd /location/of/builder/profile"
	echo "	2. builder -i NAME.${EXT_BLDR}"
	echo "	3. cd /package/source/code/directory"
	echo "	4. builder -{bc} NAME"
	echo "	   NOTES:"
	echo "	   - if no profile 'params' file exists, add any desired switches"
	echo "	   - to create a distributable software package, use the -b switch"
	echo "	   - to only compile the software (end user), pass the -c switch"
	echo
	echo "  Profile Creation Steps:                          [developer/package creator]"
	echo "	 1. Use (or create) a 'config' in ${DIR_CONF} (or ~/.$(echo "${DIR_CONF}" | sed 's/^.//'))"
	echo "	 2. Run: builder -t info NAME"
	echo "	 3. Fill out ${DIR_TEMP}/NAME.info"
	echo "	 4. Run: builder -t profile NAME"
	echo "	 5. Fill out ${DIR_TEMP}/NAME/config"
	echo "	 6. Optionally fill out ${DIR_TEMP}/NAME/params, or delete the file"
	echo "	 7. Delete ${DIR_TEMP}/NAME/proper if the directory should NOT be"
	echo "	    cleaned after compiling"
	echo "	 8. Create any 'hook' scripts (e.g. pre.compile), or delete them"
	echo "	 9. Add appropriate files under the 'include' subdirectories"
	echo "	10. Add any desired extra files under the 'extras' directory"
	echo "	11. Add any desired patches under the 'patches' directory"
	echo "	12. cd ${DIR_TEMP}"
	echo "	13. Run: builder -p NAME"
	echo
	echo "  Profile Contents Key:"
	echo "	extras [directory]"
	echo "	  stores any files that are useful to the compiled program"
	echo "	  (e.g. apachee httpd.conf for php); useful when DIRS=TRUE"
	echo "	  NOTES:"
	echo "	  - the files here need manual placement if they will be used"
	echo "	include [directory]"
	echo "	  contains items like .desktop files, icons, install markers/scripts,"
	echo "	  service scripts, etc. (e.g. include/DIR_ETC/php/php.conf)"
	echo "	  NOTES:"
	echo "	  - do NOT rename the subdirectories (e.g. DIR_ETC)!"
	echo "	  - the files in these directories get installed automatically"
	echo "	patches [directory]"
	echo "	  list of patches to apply to the codebase; they are applied in the"
	echo "	  order of an 'ls -1' - name appropriately!"
	echo "	config [file]"
	echo "	  the compile configuration for the software"
	echo "	params [file]"
	echo "	  its presence indicates the proper switches are listed here instead"
	echo "	  of passing the parameters on the command line"
	echo "	proper [file]"
	echo "	  its presence indicates a final cleanup"
	echo
	echo "	- For flexibility there are 'hook' scripts that can be incorporated"
	echo "	  to execute at various steps of operation:"
	echo "	      pre.compile	executed right before compiling"
	echo "	      post.configure	executed after a generated config"
	echo "	      post.compile	executed after compiling"
	echo "	      pre.package	executed right before packaging"
	echo "	      post.package	executed after packaging"
	echo "	      cleanup		executed as last command before exiting"
	echo "	- For multi-pass compiles, name the files in a mannor such as:"
	echo "	      pre.compile.1, pre.compile.2, config.1, config.2, etc"
	echo "	      (also apply to the 'include' directory - include.1/DIR_ETC)"
	echo
	echo "  Notes:"
	echo "	- Unless the '-C' switch was passed, with an accompanying config file"
	echo "	  CODE value, you must start this program from within the source code"
	echo "	  directory where the 'configure', 'autogen', etc scripts reside."
	echo "	- The '-C dir' looks in DIR_REPO for source code."
	echo "	- The '-D' switch is useful for making multiple packages from"
	echo "	  a single compile (e.g. php, php-cli, php-fpm, ...)"
	echo "	- It is possible to compile multiple softwares with a single"
	echo "	  builder profile (e.g. alsa-libs, alsa-utils) - see NOTES"
	echo
	exit 0
elif [ "$1" = '--version' ]; then
	head -5 $0 | grep Updated | sed "s/.*\\t//;s/ .*//;s:/:.:g"
	exit 0
else
	TEMP=0
	while getopts A:bcC:dDeFiIN:pPrR:St:T:U OPTION; do					# NOTE: the 'A:' indicates that the '-A' switch requires a value!
		( echo $OPTION | grep -qe '[a-z]' ) && TEMP=1					# if we've reached an ACTION, then...
		if [ $TEMP -gt 0 ] && ( echo $OPTION | grep -qe '[A-Z]' ); then			# if an ACTION was already processed -AND- we've reached an OPTION, then...
			echo "ERROR: All OPTIONS must preceed the ACTION."
			exit 1
		fi

		case ${OPTION} in
# UPDATED 2026/02/12
#			A) ARCH="$OPTARG" ;;
			A) ( echo "${OPTARG}" | grep -qE ^"($(echo ${CPU} | sed 's/,/|/g'))"$ ) || {
				echo "ERROR: An invalid value for '-A' was passed."
				exit 1
			   }
			   ARCH="$OPTARG" ;;
			b) BUILD='TRUE' ;;
			c) COMPILE='TRUE' ;;
			C) if ( ! echo "${WGET}" | grep -qE ^'(dev|dir|git|repo)'$ ); then
				echo "ERROR: An invalid value for '-C' was passed."
				exit 1
			   fi
			   WGET="$OPTARG" ;;
			d) DOWNLOAD='TRUE' ;;
			D) DIRS='TRUE' ;;
# UPDATED 2026/02/12
#			e) EXAMPLE=TRUE ;;
			F) SKIP='TRUE' ;;
			i) INSTALL='TRUE' ;;
			I) INFOFILE='TRUE' ;;
			N) PASS="$OPTARG" ;;
			p) PROFILE='TRUE' ;;
			P) PATCH='' ;;
			r) REPACK='TRUE' ;;
			R) TRIM="$OPTARG" ;;
			S) SINGLE='TRUE' ;;
# UPDATED 2026/02/12
#			t) TEMPLATE='TRUE' ;;
			t) if ( ! echo "${OPTARG}" | grep -qE ^'(info|profile)'$ ); then
				echo "ERROR: An invalid value for '-t' was passed."
				exit 1
			   fi
			   TEMPLATE="$OPTARG" ;;
			T) TYPE="$OPTARG" ;;
			U) UNLOAD='TRUE' ;;
			*) exit 1 ;;				# NOTE: since 'getopts' presents it own error, we don't need to do so here
		esac
	done




	# TEST FOR MANDATORY VALUE(S)

	EXE_CMD="${0##*/} $@"									# store the executed command for logging below
	shift $(expr $OPTIND - 1)				# now that the ACTIONS and OPTIONS have been processed, lets process the package name(s)
	eval NAME=\${$#}					# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script
	( [ "$NAME" = '' ] || [ "$NAME" = "$0" ] ) && { echo "ERROR: you must provide a name before processing can begin."; exit 1; }	# if a blank value was given -OR- no value given at all (since the 'shift' command will go back to $0)
fi




# MANDATORY CHECKS BEFORE **ANY** PROCESSING

# action checking			NOTE: we can't write to a log yet since those checks haven't occurred
TEMP=0
[ "$BUILD" ] && TEMP=$(( TEMP + 1 ))
[ "$COMPILE" ] && TEMP=$(( TEMP + 1 ))
[ "$DOWNLOAD" ] && TEMP=$(( TEMP + 1 ))
# UPDATED 2026/02/12
#[ "$EXAMPLE" ] && TEMP=$(( TEMP + 1 ))
[ "$INSTALL" ] && TEMP=$(( TEMP + 1 ))
[ "$REPACK" ] && TEMP=$(( TEMP + 1 ))
[ "$TEMPLATE" ] && TEMP=$(( TEMP + 1 ))
[ $TEMP -gt 1 ] && { echo "ERROR: Include only one ACTION when executing this script."; exit 1; }
[ $TEMP -eq 0 ] && { echo "ERROR: You must provide an ACTION when executing this script."; exit 1; }

# option checking
[ "$SKIP" ] && [ ! "$PASS" ] && { echo "ERROR: The '-F' option requires a valid '-N' value."; exit 1; }
if [ "$WGET" != '' ]; then
	TEMP=''
	( ( [ "$WGET" = 'dev' ] && [ ! "$URL_CODE" ] ) || ( [ "$WGET" = 'dir' ] && [ ! "$DIR_REPO" ] ) || ( [ "$WGET" = 'git' ] && [ ! "$GIT_REPO" ] ) || ( [ "$WGET" = 'repo' ] && [ ! "$URL_REPO" ] ) ) && {
		[ "$WGET" = 'dev' ] && TEMP='URL_CODE'
		[ "$WGET" = 'dir' ] && TEMP='DIR_REPO'
		[ "$WGET" = 'git' ] && TEMP='GIT_REPO'
		[ "$WGET" = 'repo' ] && TEMP='URL_REPO'

		echo "ERROR: The '-C $WGET' option requires a $TEMP value."
		exit
	}

	[ "$WGET" = 'git' ] && [ ! "$(which git)" ] && {
		echo "ERROR: The git binary is missing and is necessary when using '-C git'."
		exit
	}
fi

# set default/uninitialized variable values							  NOTE: we have to set these here since they rely on functions above
eval LOG="$LOG"

eval DIR_DUMP="$DIR_DUMP"
# REMOVED 2026/02/12
#eval DIR_INCL="$DIR_INCL"
eval DIR_INST="$DIR_INST"
eval DIR_PROF="$DIR_PROF"
# REMOVED 2026/02/12
#eval DIR_MODS="$DIR_MODS"
eval DIR_REPO="$DIR_REPO"
eval DIR_TEMP="$DIR_TEMP"
# REMOVED 2026/02/12
#eval DIR_XTRA="$DIR_XTRA"

eval URL_CODE="$URL_CODE"
eval URL_INFO="$URL_INFO"

[ "$ARCH" = 'a32' ] && EXPORTS="$FLAG_A32"
[ "$ARCH" = 'a64' ] && EXPORTS="$FLAG_A64"
[ "$ARCH" = 'i32' ] && EXPORTS="$FLAG_I32"
[ "$ARCH" = 'i64' ] && EXPORTS="$FLAG_I64"
[ "$ARCH" = 'r32' ] && EXPORTS="$FLAG_R32"
[ "$ARCH" = 'r64' ] && EXPORTS="$FLAG_R64"


# check the directories		NOTE: we can't write to a log yet since those checks are occurring
if [ ! -d "${DIR_DUMP}/${NAME}" ]; then
	mkdir -p "${DIR_DUMP}/${NAME}" >/dev/null 2>&1 || { echo "ERROR: The staging location directory (DIR_DUMP) does not exist and could not be created."; exit 1; }
fi
touch "${DIR_DUMP}/${NAME}/writable" >/dev/null 2>&1 || { echo "ERROR: The staging location directory (DIR_DUMP) is not writable."; exit 1; }
rm "${DIR_DUMP}/${NAME}/writable" >/dev/null 2>&1

if [ ! -d "${LOG%/*}" ]; then
	mkdir -p "${LOG%/*}" >/dev/null 2>&1 || { showMsg 'failure' "The logs directory (${LOG%/*}) does not exist and could not be created." 'screen'; exit 1; }
fi
touch "${LOG%/*}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The logs directory ($LOG%/*}) is not writable." 'screen'; exit 1; }
rm "${LOG%/*}/writable" >/dev/null 2>&1

if [ ! -d "$DIR_REPO" ]; then
	mkdir -p "$DIR_REPO" >/dev/null 2>&1 || { echo "ERROR: The local software repository (DIR_REPO) does not exist and could not be created."; exit 1; }
fi
touch "${DIR_REPO}/writable" >/dev/null 2>&1 || { echo "ERROR: The local software repository (DIR_REPO) is not writable."; exit 1; }
rm "${DIR_REPO}/writable" >/dev/null 2>&1

if [ ! -d "${DIR_TEMP}/${NAME}" ]; then
	mkdir -p "${DIR_TEMP}/${NAME}" >/dev/null 2>&1 || { echo "ERROR: The temporary directory (DIR_TEMP) does not exist and could not be created."; exit 1; }
fi
touch "${DIR_TEMP}/${NAME}/writable" >/dev/null 2>&1 || { echo "ERROR: The temporary directory (DIR_TEMP) is not writable."; exit 1; }
rm "${DIR_TEMP}/${NAME}/writable" >/dev/null 2>&1





if [ ! "$PASS" ] || [ $PASS -eq 1 ]; then
	echo "---------- [ Script Execution ] ----------" >"$LOG"
	echo "           $(date +'%Y-%m-%d  %H:%M:%S')" >>"$LOG"
	echo >>"$LOG"
	echo "$EXE_CMD" >>"$LOG"
elif [ "$PASS" ]; then
	echo -e "\n\n\n\n" >>"$LOG"				# add some breaks between builds if the log already exists
	echo "------- PASS: ${PASS}  $(date +'%Y-%m-%d %H:%M:%S') -------" >>"$LOG"
fi




# PROCESS THE ACTIONS

if [ "$DOWNLOAD" ]; then
	echo -e "\nDownloading the requested builder profile..." | tee -a "$LOG"

	echo -e "Calling: wget -cq \"${URL_REPO}/${NAME}.${EXT_BLDR}\" -O \"./${NAME}.${EXT_BLDR}\"" >>"$LOG"
	( wget -cq "${URL_REPO}/${NAME}.${EXT_BLDR}" -O "./${NAME}.${EXT_BLDR}" 2>&1 | tee -a "$LOG" | grep -q 404 ) && {
		echo "ERROR: The package builder profile download failed (${NAME}.${EXT_BLDR})." | tee -a "$LOG"
		return 1
	}
	exit 0


elif [ "$INSTALL" ]; then
	echo -e "\nInstalling the requested builder profile..." | tee -a "$LOG"

# DEBUG
#DIR_PROF='/tmp/zebra/test/ing'
	[ ! -e "$NAME" ] && {
		echo "ERROR: No filename exists with that value. If a prior attempt failed, then the"
		echo "       filename has probably changed."
		exit 1
	}

	TEMP='_'									# store a bogus name in case the following 'if' is by-passed (to prevent a bug in the next 'if' block)
	if [ "$(file -b --mime-type "$NAME")" = 'application/x-gzip' ]; then		# if the profile hasn't been checked that it isn't already installed, then...
		echo "Calling: mv \"$NAME\" \"${NAME}.tgz\"" >>"$LOG"
		mv "$NAME" "${NAME}.tgz"						# NOTE: we have to do this step because gunzip will complain about the file extension being unknown (since it changes a tgz|tar.gz to tar)

		echo "Calling: gunzip \"${NAME}.tgz\"" >>"$LOG"
		gunzip "${NAME}.tgz" 2>>"$LOG" || {					#   decompress it
			echo "ERROR: The builder profile could not be decompressed." >>"$LOG"
			stop failed
		}
# REMOVED 2026/02/12
#		NAME="$(echo "$NAME" | sed 's/\.tgz$//').tar"

		echo "Calling: mv \"${NAME}.tar\" \"$NAME\"" >>"$LOG"
		mv "${NAME}.tar" "$NAME"						# now we return to the original file extention

		echo "Calling: tar -tf \"$NAME\" | head -1" >>"$LOG"
		TEMP="$(tar -tf "$NAME" 2>>"$LOG" | head -1)"				#   store its parent directory name
		[ "$TEMP" = '' ] && {
			echo "ERROR: The builder profile could not be read." >>"$LOG"
			stop failed
		}
	fi

	[ -e "${DIR_PROF}/${TEMP}" ] && {						# check that that name does NOT already exist in the profile listings
		echo "ERROR: A profile with that name already exists. Either rename or delete it."
		echo "       The existing profile is: ${DIR_PROF}/${TEMP}"
		exit 1
	}

	if [ "$(file -b --mime-type "$NAME")" = 'application/x-tar' ]; then		# if the profile has been checked and does not exist, then...
		echo "Calling: tar -xf \"$NAME\"\ -C \"$DIR_PROF\"" >>"$LOG"
		tar -xf "$NAME" -C "$DIR_PROF" 2>>"$LOG" || {
			echo "ERROR: The builder profile could not be installed." >>"$LOG"
			stop failed
		}
	else										# NOTE: this is a safety-net in case something is wrong with the file
		echo "ERROR: The builder profile appears to be the wrong format." >>"$LOG"
		exit 1
	fi

	echo
	echo "The profile has been installed successfully!"
	echo
	exit 0


elif [ "$PROFILE" ]; then
	[ ! -d "$NAME" ] && {
		echo "ERROR: No directory exists with that name."
		exit 1
	}
	echo "Calling: tar -czf \"${NAME}.${EXT_BLDR}\"\ \"$NAME\"" >>"$LOG"
	tar -czf "${NAME}.${EXT_BLDR}" "$NAME" 2>>"$LOG" || {
		echo "ERROR: The builder profile could not be created." >>"$LOG"
		exit 1
	}
	exit 0


elif [ "$REPACK" ]; then
	package
	exit 0


# UPDATED 2026/02/12
#elif [ "$EXAMPLE" ]; then
elif [ "$TEMPLATE" = 'info' ]; then
	echo -e "\nCreating a package .info file template..." | tee -a "$LOG"
	echo "name:		${NAME}" >"${DIR_TEMP}/${NAME}.info"
	echo "title:		Concise title" >>"${DIR_TEMP}/${NAME}.info"
	echo "description:	Short description" >>"${DIR_TEMP}/${NAME}.info"
	echo "version:	1.2.3" >>"${DIR_TEMP}/${NAME}.info"
	echo "released:	YYYY.MM.DD" >>"${DIR_TEMP}/${NAME}.info"
	echo "packaged:	YYYY.MM.DD" >>"${DIR_TEMP}/${NAME}.info"
	echo "authors:	Name(s)" >>"${DIR_TEMP}/${NAME}.info"
	echo "homepage:	https://www.company.com" >>"${DIR_TEMP}/${NAME}.info"					# 	NOTE: these are all appended to main URL (homepage, git, repo)
	echo "download:	path/to/file/filename.tgz" >>"${DIR_TEMP}/${NAME}.info"					# oem direct download link from their website
	echo "git:		https://distributor.com/path/to/project" >>"${DIR_TEMP}/${NAME}.info"		# oem git url
	echo "commit:		path/to/commit/abcd...wxyz" >>"${DIR_TEMP}/${NAME}.info"			# 	the commit that this package is based on (similar to version)
	echo "file:		path/to/file/filename.tgz" >>"${DIR_TEMP}/${NAME}.info"				# files associated with that
	echo "clone:		.git" >>"${DIR_TEMP}/${NAME}.info"						# to clone a repo locally
	echo "repo:	http://domain.com/path/to/project" >>"${DIR_TEMP}/${NAME}.info"				# linux distro repo url
	echo "package:	example-1.2.3.soft" >>"${DIR_TEMP}/${NAME}.info"					# files associated with that
	echo "source:		example-1.2.3.${EXT_CODE}" >>"${DIR_TEMP}/${NAME}.info"
	echo "builder:	example-1.2.3.${EXT_BLDR}" >>"${DIR_TEMP}/${NAME}.info"
	echo "compile:	example-1.2.3.${EXT_MAKE}" >>"${DIR_TEMP}/${NAME}.info"
	echo "size:		100K" >>"${DIR_TEMP}/${NAME}.info"
	echo "category:	system" >>"${DIR_TEMP}/${NAME}.info"
	echo "interface:	gui	# valid values: cli,gui" >>"${DIR_TEMP}/${NAME}.info"
	echo "toolkit:	gtk2	# [CLI] shell|lua|ruby|php|python|tcl|tk|..., [GUI] fltk|gtk|html|qt|wxWidgets|..." >>"${DIR_TEMP}/${NAME}.info"
	echo "rating:		g" >>"${DIR_TEMP}/${NAME}.info"
	echo "license:	LGPLv2.1" >>"${DIR_TEMP}/${NAME}.info"
	echo "document:	https://www.gnu.org/licenses/lgpl-2.1.en.html" >>"${DIR_TEMP}/${NAME}.info"
	echo "maintainer:	example_maintainer_alias" >>"${DIR_TEMP}/${NAME}.info"
	echo "tags:		space separated project keywords" >>"${DIR_TEMP}/${NAME}.info"
	echo "overview:	This is a detailed overview for the example project" >>"${DIR_TEMP}/${NAME}.info"
	echo "comments:	Any applicable comments for the package" >>"${DIR_TEMP}/${NAME}.info"
	echo "changes:	Brief list of changes between package releases" >>"${DIR_TEMP}/${NAME}.info"

	echo | tee -a "$LOG"
	echo "The sample .info file has been successfully created! It can be found at:" | tee -a "$LOG"
	echo "  ${DIR_TEMP}/${NAME}.info" | tee -a "$LOG"
	echo | tee -a "$LOG"
	exit 0


# UPDATED 2026/02/12
#elif [ "$TEMPLATE" ]; then
elif [ "$TEMPLATE" = 'profile' ]; then
	echo -e "\nCreating a builder profile template..." | tee -a "$LOG"

	[ -e "${DIR_TEMP}/${NAME}" ] && {
		echo "ERROR: a profile with that name already exists."
		exit 1
	}
	echo "Calling: mkdir -p \"${DIR_TEMP}/${NAME}\"" >>"$LOG"
	mkdir -p "${DIR_TEMP}/${NAME}" >>"$LOG" 2>&1 || {
		echo "ERROR: The profile directory (DIR_TEMP) does not exist or could not be created." >>"$LOG"
		stop failed
	}
	cd "${DIR_TEMP}/${NAME}" >/dev/null
	echo "Calling: mkdir -p \"${DIR_TEMP}/${NAME}\"" >>"$LOG"
	mkdir -p extras include patches >>"$LOG" 2>&1 || {
		echo "ERROR: The profile directory (DIR_TEMP) does not exist or could not be created." >>"$LOG"
		stop failed
	}
	cd "${DIR_TEMP}/${NAME}/include" >/dev/null
	echo "Calling: mkdir -p \"${DIR_TEMP}/${NAME}\"" >>"$LOG"
	mkdir -p DIR_BIN DIR_ETC DIR_LIB DIR_SBIN DIR_SHARE DIR_VAR DIR_MARKERS DIR_SCRIPTS CFG_BIN CFG_DATA CFG_DATAROOT CFG_DOC CFG_DVI CFG_HTML CFG_INCLUDE CFG_INFO CFG_LIB CFG_LIBEXEC CFG_LOCALE CFG_LOCALSTATE CFG_MAN CFG_OLDINCLUDE CFG_PDF CFG_PS CFG_SBIN CFG_SHAREDSTATE CFG_SYSCONFIG CFG_MISC >>"$LOG" 2>&1 || {
		echo "ERROR: The profile directory (DIR_TEMP) does not exist or could not be created." >>"$LOG"
		stop failed
	}
	echo "- Do NOT rename these directories!" >"README.txt"
	echo "- Place appropriate files in the appropriate directories." >>"README.txt"
	echo "- Empty directories can be deleted if desired." >>"README.txt"
	echo "- This file can be deleted." >>"README.txt"
	echo >>"README.txt"
	echo "Directory Installation Locations:" >>"README.txt"
	echo "DIR_BIN		LSB: /bin" >>"README.txt"
	echo "DIR_ETC		LSB: /etc" >>"README.txt"
	echo "DIR_LIB		LSB: /lib" >>"README.txt"
	echo "DIR_SBIN		LSB: /sbin		XSB: /bin" >>"README.txt"
	echo "DIR_SHARE		LSB: /usr/share		XSB: /var/share" >>"README.txt"
	echo "DIR_VAR		LSB: /var" >>"README.txt"
	echo "DIR_MARKERS	LSB: -			XSB: /var/cache/software" >>"README.txt"
	echo "DIR_SCRIPTS	LSB: /etc/init.d" >>"README.txt"
	echo >>"README.txt"
	echo "Compile 'configure' Directory Locations:" >>"README.txt"
	echo "CFG_BIN		LSB: DIR_INST/bin" >>"README.txt"
	echo "CFG_DATA		LSB: DIR_INST/share	XSB: DIR_INST/var/share" >>"README.txt"
	echo "CFG_DATAROOT	LSB: CFG_DATA" >>"README.txt"
	echo "CFG_DOC		LSB: CFG_DATA/doc/NAME" >>"README.txt"
	echo "CFG_DVI		LSB: CFG_DOC" >>"README.txt"
	echo "CFG_HTML		LSB: CFG_DOC" >>"README.txt"
	echo "CFG_INCLUDE	LSB: DIR_INST/include	XSB: DIR_INST/lib/include" >>"README.txt"
	echo "CFG_INFO		LSB: CFG_DATA/info" >>"README.txt"
	echo "CFG_LIB		LSB: DIR_INST/lib" >>"README.txt"
	echo "CFG_LIBEXEC	LSB: DIR_INST/libexec	XSB: CFG_LIB" >>"README.txt"
	echo "CFG_LOCALE	LSB: CFG_DATA/locale" >>"README.txt"
	echo "CFG_LOCALSTATE	LSB: DIR_INST/var" >>"README.txt"
	echo "CFG_MAN		LSB: CFG_DATA/man" >>"README.txt"
	echo "CFG_OLDINCLUDE	LSB: /usr/local/include	XSB: DIR_INST/lib/include" >>"README.txt"
	echo "CFG_PDF		LSB: CFG_DOC" >>"README.txt"
	echo "CFG_PS		LSB: CFG_DOC" >>"README.txt"
	echo "CFG_SBIN		LSB: DIR_INST/sbin	XSB: DIR_INST/bin" >>"README.txt"
	echo "CFG_SHAREDSTATE	LSB: DIR_INST/com	XSB: DIR_INST/var" >>"README.txt"
	echo "CFG_SYSCONFIG	LSB: DIR_INST/etc" >>"README.txt"
	echo "CFG_MISC		" >>"README.txt"
	echo >>"README.txt"
	echo "The CFG_MISC is a builder extra variable that can be used per project, but will" >>"README.txt"
	echo "need its associated switch. So, for example, mplayer has a non-standard switch" >>"README.txt"
	echo "to place its codecs. Simply enter \"--codec-dir='/whatever/dir'\" for this" >>"README.txt"
	echo "variable value to use it." >>"README.txt"

	cd ..
	echo "The presence of this file indicates that a final cleanup" >proper
	echo "call will be initiated. If this is undesired, then delete" >>proper
	echo "this file." >>proper

	echo "# Specify any default parameter values using this file." >params
	echo "# These can be overwritten via passed values. This file" >>params
	echo "# can also be deleted to accept default values." >>params
	echo >>params
	echo "ARCH='all'" >params
	echo "DIRS=''" >>params
	echo "PASS=''" >>params
	echo "SKIP=''" >>params
	echo "TRIM=''" >>params
	echo "TYPE='default'" >>params
	echo "WGET=''" >>params

	echo "#!/bin/sh" >pre.compile
	echo "# Specify any pre-compile actions in this script. If there" >>pre.compile
	echo "# aren't any, then this file can be deleted." >>pre.compile
	echo >>pre.compile
	chmod 775 pre.compile

	echo "#!/bin/sh" >post.compile
	echo "# Specify any post-compile actions in this script. If there" >>post.compile
	echo "# aren't any, then this file can be deleted." >>post.compile
	echo >>post.compile
	chmod 775 post.compile

	echo "#!/bin/sh" >post.configure
	echo "# Specify any post-configure actions in this script. If there" >>post.configure
	echo "# aren't any, then this file can be deleted." >>post.configure
	echo >>post.configure
	chmod 775 post.configure

	echo "#!/bin/sh" >pre.package
	echo "# Specify any pre-package actions in this script. If there" >>pre.package
	echo "# aren't any, then this file can be deleted." >>pre.package
	echo >>pre.package
	chmod 775 pre.package

	echo "#!/bin/sh" >post.package
	echo "# Specify any post-package actions in this script. If there" >>post.package
	echo "# aren't any, then this file can be deleted." >>post.package
	echo >>post.package
	chmod 775 post.package

	echo "#!/bin/sh" >cleanup
	echo "# Specify any final actions before the termination of this" >>cleanup
	echo "# script. If there aren't any, then this file can be deleted." >>cleanup
	echo >>cleanup
	chmod 775 cleanup

	echo "# Toggle the execution for any of these commands" >config
	echo "# NOTE: when using multi-pass files (e.g. config.1, config.2), these can be used" >>config
	echo "#       to define which pass any of these commands are executed depending on the" >>config
	echo "#       value assigned in each config file" >>config
	echo "CHECK=0		# make check" >>config
	echo "CLEAN=1		# make clean; NOTE: a '2' value performs a 'make distclean'" >>config
	echo "CONF=1		# configure" >>config
	echo "PROP=0		# make mrproper" >>config
	echo "TEST=0		# make test" >>config
	echo "SORT=TRUE	# indicates the package contents need sorting (on this pass)" >>config
	echo >>config
	echo "# The URL to the developers source code used with this builder profile" >>config
	echo "# NOTES:" >>config
	echo "#     - if doing multi-pass, this needs to be in the first config file" >>config
	echo "#     - this is optional but does allow a '-C dev' call" >>config
	echo "URL_CODE=''" >>config
	echo >>config
	echo "# Same as above, but the URL to the online git repo for the project" >>config
	echo "GIT_REPO=''" >>config
	echo >>config
	echo "# The below variable is optional and should only be used when compiling more" >>config
	echo "# than one software with a single builder profile. For example you can compile" >>config
	echo "# both alsa-libs and alsa-utils with a single 'builder alsa' command if the" >>config
	echo "# config.1 CODE value is 'alsa-libs' and config.2 CODE value is 'alsa-utils'." >>config
	echo "# This value would uniquely identify which source code directory to use per pass" >>config
	echo "CODE=''" >>config
	echo >>config
	echo "# If the compile type is 'custom', you need to specify all commands here" >>config
	echo "# For example: gcc -O whatever" >>config
	echo "# NOTE: if this contains variables, still surround them in single quotes!!!" >>config
# UPDATED 2026/02/12
#	echo "COMPILE=''" >>config
	echo "CUSTOM=''" >>config
	echo >>config
	echo "# Uncomment any of the directory installation locations you wish to modify" >>config
	echo "#DIR_BIN=\"\${DIR_INST}/bin\"" >>config
	echo "#DIR_ETC=\"\${DIR_INST}/etc\"" >>config
	echo "#DIR_LIB=\"\${DIR_INST}/lib\"" >>config
	echo "#DIR_SBIN=\"\${DIR_INST}/sbin\"" >>config
	echo "#DIR_SHARE=\"\${DIR_INST}/share\"" >>config
	echo "#DIR_VAR=\"\${DIR_INST}/var\"" >>config
	echo "#DIR_MARKERS=\"\${DIR_INST}/usr/local/tce.installed\"" >>config
	echo "#DIR_SCRIPTS=\"\${DIR_INST}/etc/init.d\"" >>config
	echo >>config
	echo "# Modify any of the directory configuration locations below" >>config
	echo "CFG_BIN=\"\${DIR_INST}/bin\"" >>config
	echo "CFG_DATA=\"\${DIR_INST}/share\"" >>config
	echo "CFG_DATAROOT=\"\${CFG_DATA}\"" >>config
	echo "CFG_DOC=\"\${CFG_DATA}/doc/NAME\"" >>config
	echo "CFG_DVI=\"\${CFG_DOC}\"" >>config
	echo "CFG_HTML=\"\${CFG_DOC}\"" >>config
	echo "CFG_INCLUDE=\"\${DIR_INST}/include\"" >>config
	echo "CFG_INFO=\"\${CFG_DATA}/info\"" >>config
	echo "CFG_LIB=\"\${DIR_INST}/lib\"" >>config
	echo "CFG_LIBEXEC=\"\${DIR_INST}/libexec\"" >>config
	echo "CFG_LOCALE=\"\${CFG_DATA}/locale\"" >>config
	echo "CFG_LOCALSTATE=\"\${DIR_INST}/var\"" >>config
	echo "CFG_MAN=\"\${CFG_DATA}/man\"" >>config
	echo "CFG_OLDINCLUDE=\"/usr/include\"" >>config
	echo "CFG_PDF=\"\${CFG_DOC}\"" >>config
	echo "CFG_PS=\"\${CFG_DOC}\"" >>config
	echo "CFG_SBIN=\"\${DIR_INST}/sbin\"" >>config
	echo "CFG_SHAREDSTATE=\"\${DIR_INST}/com\"" >>config
	echo "CFG_SYSCONFIG=\"\${DIR_INST}/etc\"" >>config
	echo "# The CFG_MISC is a builder extra variable that can be used per project, but will" >>config
	echo "# need its associated switch. So, for example, mplayer has a non-standard switch" >>config
	echo "# to place its codecs. Simply enter \"--codec-dir='/whatever/dir'\" for this" >>config
	echo "# variable value to use it." >>config
	echo "#CFG_MISC=\"\"" >>config
	echo >>config
	echo "# Specify run-time package dependency list for each package type:" >>config
	echo "# (e.g. DEP_MAKE_PAK='autogen')" >>config
	echo "# if all compiled files go in a single package, use _ALL below" >>config
	echo "DEP_EXEC_ALL=''		# all files in a single package instead of splitting below" >>config
	echo "DEP_EXEC_BIN=''		# only binaries" >>config
	echo "DEP_EXEC_DEV=''		# ony development files (e.g. *.h headers)" >>config
	echo "DEP_EXEC_DOC=''		# only documentation" >>config
	echo "DEP_EXEC_DRV=''		# only kernel drivers" >>config
	echo "DEP_EXEC_GIR=''		# only gir files" >>config
	echo "DEP_EXEC_LIB=''		# only libs" >>config
	echo "DEP_EXEC_LOC=''		# only locale files" >>config
	echo "# Specify compile-time package dependency list to build this software" >>config
	echo "DEP_MAKE_PAK=''" >>config
	echo >>config
	echo "FLAG_CONF=\"--prefix=\${DIR_INST}\"		# parameters to pass to 'configure'" >>config
	echo "FLAG_INST=\"DESTDIR=\${DIR_DUMP}/\${NAME}\"		# parameters to pass to 'make install'" >>config
	echo "FLAG_MAKE=''					# parameters to pass to 'make'" >>config
	echo >>config
	echo "# If you wish to override the system defaults for this package, adjust the following:" >>config
	echo "#FLAG_A32=\"${FLAG_A32}\"			# ARM 32bit" >>config
	echo "#FLAG_A64=\"${FLAG_A64}\"			# ARM 64bit" >>config
	echo "#FLAG_I32=\"${FLAG_I32}\"			# Intel/AMD 32bit" >>config
	echo "#FLAG_I64=\"${FLAG_I64}\"			# Intel/AMD 64bit" >>config
	echo "#FLAG_R32=\"${FLAG_R32}\"			# RPi 32bit" >>config
	echo "#FLAG_R64=\"${FLAG_R64}\"			# RPi 64bit" >>config

	echo
	echo "The template builder profile has been successfully created! It can be found at:"
	echo "  ${DIR_TEMP}/${NAME}"
	echo
	exit 0


#elif [ "$BUILD" ] || [ "$COMPILE" ]; then
#	if we're building or compiling, then all the below code needs to run
fi




# BEGIN THE BUILD/COMPILE PROCESS

# for optional values not configured above
if [ ! "$ARCH" ] || [ "$ARCH" = 'all' ]; then		# if the default (which is all) or a specified 'all' was passed, then...
	# cycle each defined CPU architecture and compile
	for ARCH in $(echo ${CPU} | sed 's/,/ /g'); do	# call this script again for all supported CPU architecture and exit
		TEMP='"$THIS" -A "$ARCH" -T "$TYPE"'
		[ "$WGET" != '' ] && TEMP="$TEMP -C $WGET"
		[ "$DIRS" ] && TEMP="$TEMP -D"
		[ "$PASS" ] && TEMP="$TEMP -N '$PASS'"
		[ "$PATCH" ] && TEMP="$TEMP -P"
		[ "$SKIP" ] && TEMP="$TEMP -F"
		[ "$SINGLE" ] && TEMP="$TEMP -S"
		[ "$TRIM" ] && TEMP="$TEMP -R \"$TRIM\""
		[ ! "$UNLOAD" ] && TEMP="$TEMP -U"

		eval $TEMP "$NAME"
	done
	exit 0
fi
[ ! "$TYPE" ] && TYPE='default'

# MOVED 2026/02/12
## update directory locations to process any included variables in them
#eval DIR_DUMP="$DIR_DUMP"
#eval DIR_INCL="$DIR_INCL"
#eval DIR_INST="$DIR_INST"
#eval DIR_MAKE="$DIR_MAKE"
#eval DIR_MODS="$DIR_MODS"
#eval DIR_REPO="$DIR_REPO"
#eval DIR_TEMP="$DIR_TEMP"
#eval DIR_XTRA="$DIR_XTRA"
#
## update URL locations to process any included variables in them
#eval URL_CODE="$URL_CODE"
#eval URL_INFO="$URL_INFO"

# REMOVED 2026/02/11 - this is already performed at the top of the script
#	# if a parameters file is present, read in its values
#	[ -e "${DIR_MAKE}/params" ] && . "${DIR_MAKE}/params"										# Global package parameters	NOTE: these can completely specify or compliment passed switches (which override these)
#	[ -e "/usr/local/${DIR_MAKE}/params" ] && . "/usr/local/${DIR_MAKE}/params"							# ditto as alternate location
#	[ -e "${HOME}/.$(echo "${DIR_MAKE}" | tail -c +2)/params" ] && . "${HOME}/.$(echo "${DIR_MAKE}" | tail -c +2)/params"		# ditto as personalized params file - using XSB
#	[ -e "${HOME}/.${DIR_MAKE##*/}/params" ] && . "${HOME}/.${DIR_MAKE##*/}/params"							# ditto as personalized params file - using LSB
#
#	OPTIND=1						# reset the global variable used by 'getopts' so it can start over	https://unix.stackexchange.com/questions/233728/bash-function-with-getopts-only-works-the-first-time-its-run
#	while getopts A:C:cDFN:PR:ST:U OPTION; do		# NOTE: we have to process the passed switches again so they take precedence over the 'params' file above
#		case ${OPTION} in
#			A) ARCH="$OPTARG" ;;
#			C) WGET="$OPTARG" ;;
#			c) COMPILE=TRUE ;;
#			D) DIRS=TRUE ;;
#			F) SKIP=TRUE ;;
#			N) PASS="$OPTARG" ;;
#			P) PATCH='' ;;
#			R) TRIM="$OPTARG" ;;
#			S) SINGLE=TRUE ;;
#			T) TYPE="$OPTARG" ;;
#			U) UNLOAD='' ;;
#		esac
#	done




# CHECK FOR PRIOR FAILED ATTEMPTS

# if either directory exists -AND- we are doing a single pass -or- on the first pass of a multi-pass (via cli or params file) and the .pass file doesn't exist (via 'stop failed'), then...
if ( [ -d "${DIR_DUMP}/${NAME}" ] || [ -d "${DIR_TEMP}/${NAME}" ] || [ -d "${DIR_TEMP}/${NAME}.bin" ] ) && ( [ ! "$PASS" ] || ( [ "$PASS" ] && [ ! -e "${DIR_TEMP}/${NAME}.pass" ] ) ); then
	echo -n "It appears a prior (attempted) compile has left files behind, cleanup? [Y/N] (N): "
	read
	[ "$REPLY" = 'Y' ] || [ "$REPLY" = 'y' ] && stop proper 0
fi




# GET/SET THE 'PASS' AND 'SUDO' VALUES				  NOTE: the DIR_TEMP value will already be (re)set by this point

[ -e "${DIR_TEMP}/${NAME}.pass" ] && {				# if we are on one of the multi-passes, then...    WARNING: this has to be processed in this order -AND- do NOT test for PASS value since it does NOT get passed on subsequent calls!
	PASS="$(cat "${DIR_TEMP}/${NAME}.pass")"
	TEMP=${PASS%|*}						#   store the total passes required
	PASS=${PASS#*|}						#   store the prior pass value
	PASS=$(( PASS + 1 ))					#   increase the value by 1
	[ $PASS -gt $TEMP ] && stop proper			#   if we have just completed the last requred pass, then cleanup and exit
	echo "${TEMP}|${PASS}" >"${DIR_TEMP}/${NAME}.pass"	#   if we've made it here, we still have at least one pass to perform, so update the values!
}

[ "$PASS" ] && [ ! -e "${DIR_TEMP}/${NAME}.pass" ] && {		# if we need to perform multi-passes and none are recorded yet, then...
	echo "${PASS}|1" >"${DIR_TEMP}/${NAME}.pass"		#   stored value in format of: TOTAL|CURRENT
	PASS=1							#   now store the value that we are working on the first pass
}

( [ "$SUDO" = 'TRUE' ] || [ "$SUDO" = '1' ] ) && SUDO='sudo'	# update the value to be the binary name so we can use it like "$SUDO mv ..."	NOTE: to use 'sudo' with parameters, simply add them for the SUDO value in the /etc/builder/config file (e.g. SUDO='sudo -x -y -z')




# MOVED 2026/02/11 - moved at the top
## LOAD PROJECT CONFIGURATION
#
#[ ! "$PASS" ] && [ -e "${DIR_MAKE}/config" ] && . "${DIR_MAKE}/config"									# Global package parameters	pickup any specific variables for the target package (if not doing a multi-pass)
#[ ! "$PASS" ] && [ -e "/usr/local/${DIR_MAKE}/config" ] && . "/usr/local/${DIR_MAKE}/config"						# ditto as alternate location
#[ ! "$PASS" ] && [ -e "${HOME}/.$(echo "${DIR_MAKE}" | tail -c +2)/config" ] && . "${HOME}/.$(echo "${DIR_MAKE}" | tail -c +2)/config"	# ditto as personalized config file - using XSB
#[ ! "$PASS" ] && [ -e "${HOME}/.${DIR_MAKE##*/}/config" ] && . "${HOME}/.${DIR_MAKE##*/}/config"					# ditto as personalized config file - using LSB
#[ "$PASS" ] && [ -e "${DIR_MAKE}/config.${PASS}" ] && . "${DIR_MAKE}/config.${PASS}"							# if we are on a multi-pass and a config exists for that pass, then read it in!
#[ "$PASS" ] && [ -e "/usr/local/${DIR_MAKE}/config.${PASS}" ] && . "/usr/local/${DIR_MAKE}/config.${PASS}"
#[ "$PASS" ] && [ -e "${HOME}/.$(echo "${DIR_MAKE}" | tail -c +2)/config.${PASS}" ] && . "${HOME}/.$(echo "${DIR_MAKE}" | tail -c +2)/config.${PASS}"
#[ "$PASS" ] && [ -e "${HOME}/.${DIR_MAKE##*/}/config.${PASS}" ] && . "${HOME}/.${DIR_MAKE##*/}/config.${PASS}"




# OPTIONALLY SHOW DEBUG OUTPUT

[ $DEBUG -gt 0 ] && {
	echo -e "\nConfiguration during this pass..." | tee -a "$LOG"
	echo "   ARCH: $ARCH" | tee -a "$LOG"
	echo "   DIRS: $DIRS" | tee -a "$LOG"
	echo "   NAME: $NAME" | tee -a "$LOG"
# REMOVED 2026/02/12
#	echo "   NOPK: $NOPK" | tee -a "$LOG"
	echo "   PASS: $PASS" | tee -a "$LOG"
	echo "   SKIP: $SKIP" | tee -a "$LOG"
	echo "   TRIM: $TRIM" | tee -a "$LOG"
	echo "   TYPE: $TYPE" | tee -a "$LOG"
	echo "   WGET: $WGET" | tee -a "$LOG"
	echo | tee -a "$LOG"
	echo "   CHECK: $CHECK" | tee -a "$LOG"
	echo "   CLEAN: $CLEAN" | tee -a "$LOG"
	echo "   CONF: $CONF" | tee -a "$LOG"
	echo "   PROP: $PROP" | tee -a "$LOG"
	echo "   SORT: $SORT" | tee -a "$LOG"
	echo "   TEST: $TEST" | tee -a "$LOG"
	echo "   CODE: $CODE" | tee -a "$LOG"
	echo | tee -a "$LOG"
	echo "   FLAG_CONF: $FLAG_CONF" | tee -a "$LOG"
	echo "   FLAG_INST: $FLAG_INST" | tee -a "$LOG"
	echo "   FLAG_MAKE: $FLAG_MAKE" | tee -a "$LOG"
	echo | tee -a "$LOG"
	echo "   DIR_DUMP: $DIR_DUMP" | tee -a "$LOG"
# REMOVED 2026/02/12
#	echo "   DIR_INCL: $DIR_INCL" | tee -a "$LOG"
	echo "   DIR_INST: $DIR_INST" | tee -a "$LOG"
	echo "   DIR_PROF: $DIR_PROF" | tee -a "$LOG"
# REMOVED 2026/02/12
#	echo "   DIR_MODS: $DIR_MODS" | tee -a "$LOG"
	echo "   DIR_REPO: $DIR_REPO" | tee -a "$LOG"
	echo "   DIR_TEMP: $DIR_TEMP" | tee -a "$LOG"
# REMOVED 2026/02/12
#	echo "   DIR_XTRA: $DIR_XTRA" | tee -a "$LOG"
	echo | tee -a "$LOG"
	echo "   URL_CODE: $URL_CODE" | tee -a "$LOG"
	echo "   URL_REPO: $URL_REPO" | tee -a "$LOG"
	echo "   URL_INFO: $URL_INFO" | tee -a "$LOG"
	echo | tee -a "$LOG"
	echo "   EXPORTS:" | tee -a "$LOG"
	echo "$EXPORTS" | sed 's/^[ \t]*/   /' | tee -a "$LOG"
}




# FETCH COMPILE-TIME DEPENDENCIES

echo -e "\nInstalling compile-time dependencies..." | tee -a "$LOG"

# for core software by builder itself
[ "$DEP_MAKE_ALL" ] && ( [ ! "$PASS" ] || [ $PASS -eq 1 ] ) && { eval $SPM_ALL 2>>"$LOG" || stop clean; }			# if we are only doing a single pass -OR- are on the first pass, then...

# for the software project itself
[ "$DEP_MAKE_PAK" ] && { eval $SPM_PACK 2>>"$LOG" || stop clean; }




# FETCH SOURCE CODE

if [ "$WGET" ]; then										# if we need to obtain the source code before we start, then...
	echo "Calling: cd \"${DIR_TEMP}/${NAME}\"" >>"$LOG"
	cd "${DIR_TEMP}/${NAME}" || {
		echo "ERROR: The temp directory could not be entered." >>"$LOG"
		stop failed
	}

	if [ "$INFOFILE" ]; then
		echo -e "\nObtaining information..." | tee -a "$LOG"

		OARCH="$ARCH"									# temporarily store the old value
		ARCH='all'
		[ "$TRIM" ] && TEMP="$(echo "$NAME" | sed "s/${TRIM}//")"			# apply package name trimming beforehand
		[ ! "$TRIM" ] && TEMP="$NAME"
		TEMP="$(echo "$URL_INFO" | sed "s/\${NAME}/$TEMP/g")"				# make name substitution in the URL (e.g. liba52 > a52)
		if [ -e "$(eval echo ${TEMP##*/})" ]; then					# if the .info file is already downloaded (to prevent an error below), then...
			TEMP="$(eval echo ${TEMP##*/})"						#   store that filename
		else										# otherwise
			eval echo "Calling: wget \"$TEMP\"" >>"$LOG"
			eval wget "$TEMP" 2>>"$LOG" || stop failed				#   download the proper .info file to get the download location and filename
			TEMP="${URL_INFO##*/}"							#   store the filename that was just downloaded
		fi
		if [ ! -e "$(grep -e ^'package:' "${TEMP}" | sed 's/.*:\t//')" ]; then
			TEMP="$(grep -i -e ^'repo:' -e ^'package:' "${TEMP}" | sed -r 's/.*:[\t]+//' | tr '\n' '/' | sed 's:/$::')"	# grep out the meaningful lines and combine to produce a valid download URL
			echo "Calling: wget \"$TEMP\"" >>"$LOG"
			wget "$TEMP" 2>>"$LOG" || stop failed
		fi
		ARCH="$OARCH"									# restore the prior value
		unset $OARCH									# get rid of that variable

		# now set the variable values for the below code blocks
		[ "$WGET" = 'dev' ] && URL_CODE="$(grep -i -e ^'homepage:' -e ^'download:' "${TEMP}" | sed -r 's/.*:[\t]+//' | tr '\n' '/' | sed 's:/$::')"
		[ "$WGET" = 'git' ] && GIT_REPO="$(grep -i -e ^'git:' -e ^'clone:' "${TEMP}" | sed -r 's/.*:[\t]+//' | tr '\n' '/' | sed 's:/$::')"
		[ "$WGET" = 'repo' ] && URL_REPO="$(grep -i -e ^'repo:' -e ^'package:' "${TEMP}" | sed -r 's/.*:[\t]+//' | tr '\n' '/' | sed 's:/$::')"
	fi

	echo -e "\nObtaining source code..." | tee -a "$LOG"

	[ "$WGET" = 'dir' ] && {
		[ "$TRIM" ] && TEMP="$(echo "$NAME" | sed "s/${TRIM}//")"			# apply the trim beforehand
		[ ! "$TRIM" ] && TEMP="$NAME"
		if [ ! -e "$(eval echo ${TEMP}${EXT_CODE})" ]; then				# if the source code is not already copied (e.g. by utilizing the same source code such as php, not like alsa-lib and alsa-config), then...
			eval EXT_CODE="$EXT_CODE"
			if [ -e "${DIR_REPO}/${TEMP}${EXT_CODE}" ]; then
				echo "Calling: cp \"${DIR_REPO}/${TEMP}${EXT_CODE}\" ./" >>"$LOG"
				cp "${DIR_REPO}/${TEMP}${EXT_CODE}" ./ 2>>"$LOG" || stop failed
			fi
			if [ -e "${DIR_REPO}/${TEMP}/${TEMP}${EXT_CODE}" ]; then
				echo "Calling: cp \"${DIR_REPO}/${TEMP}/${TEMP}${EXT_CODE}\" ./" >>"$LOG"
				cp "${DIR_REPO}/${TEMP}/${TEMP}${EXT_CODE}" ./ 2>>"$LOG" || stop failed
			fi
		fi
	}
	[ "$WGET" = 'dev' ] && {
		[ "$TRIM" ] && TEMP="$(echo "$NAME" | sed "s/${TRIM}//")"			# apply the trim beforehand
		[ ! "$TRIM" ] && TEMP="$NAME"
		if [ ! -e "$(eval echo ${TEMP}${EXT_CODE})" ]; then
			TEMP="$(echo "$URL_CODE" | sed "s/\${NAME}/${TEMP}/g")"			# make name substitution in the URL (e.g. liba52 > a52)
			eval echo "Calling: wget \"$TEMP\"" >>"$LOG"
			eval wget "$TEMP" 2>>"$LOG" || stop failed
		fi
	}
	[ "$WGET" = 'git' ] && {
		[ "$TRIM" ] && TEMP="$(echo "$NAME" | sed "s/${TRIM}//")"			# apply the trim beforehand
		[ ! "$TRIM" ] && TEMP="$NAME"
		if [ ! -e ".git" ]; then
			TEMP="$(echo "$GIT_REPO" | sed "s/\${NAME}/$TEMP/g")"			# make name substitution in the URL (e.g. liba52 > a52)
			eval echo "Calling: git clone \"$TEMP\"" >>"$LOG"
			eval git clone "$TEMP" 2>>"$LOG" || stop failed
		fi
	}
	[ "$WGET" = 'repo' ] && {
		[ "$TRIM" ] && TEMP="$(echo "$NAME" | sed "s/${TRIM}//")"			# apply the trim beforehand
		[ ! "$TRIM" ] && TEMP="$NAME"
		if [ ! -e "$(eval echo ${TEMP}${EXT_CODE})" ]; then
			TEMP="$(echo "$URL_REPO" | sed "s/\${NAME}/$TEMP/g")"			# make name substitution in the URL (e.g. liba52 > a52)
			eval echo "Calling: wget \"$TEMP\"" >>"$LOG"
			eval wget "$TEMP" 2>>"$LOG" || stop failed
		fi
	}

	if [ "$WGET" != 'git' ]; then								# if we're not cloing a git repo (since it would already be uncompressed files), then...
		TEMP="$(ls -1t | head -1)"							#    store the filename that was just downloaded
		echo "Source Code File: $TEMP" >>"$LOG"
		case $(file -b --mime-type "$TEMP") in
			'application/zip') unzip "$TEMP" 2>>"$LOG" ;;
			'application/x-gzip') tar -xzf "$TEMP" 2>>"$LOG" ;;
			'application/x-bzip2')
				[ ! -e "${TEMP%.*}" ] && bunzip2 "$TEMP" 2>>"$LOG"		#    if the file is already uncompressed, then...
				tar -xf "${TEMP%.*}" 2>>"$LOG"
				;;
		esac
	fi
	echo -e "Detected:\n$(ls -tdpr -- * | grep '/'$)" >>"$LOG"
	echo "Calling: cd \"$(ls -tdr -- * | grep '/'$ | head -1)\"" >>"$LOG"
	cd "$(ls -tdpr -- * | grep '/'$ | head -1)" 2>>"$LOG" || {				# change into the (unknown named) directory created by the copy/clone/uncompression above (source code directory)	https://unix.stackexchange.com/questions/136976/get-the-latest-directory-not-the-latest-file
		echo "ERROR: The source code directory could not be entered." >>"$LOG"
		stop failed
	}
	# NOTE: we are now in the correct directory to perform all the following actions

elif [ "$CODE" ]; then										# if we have a CODE value, then we need to change into that directory before we continue!
	echo -e "\nEntering source code directory..." | tee -a "$LOG"

	echo -e "Detected:\n$(ls -1pd -- * | grep ^"$CODE" | grep '/'$ | head -1)" >>"$LOG"
	TEMP="$(ls -1pd -- * | grep ^"$CODE" | grep '/'$ | head -1)"
	[ ! "$TEMP" ] && {
		echo "ERROR: The source code directory could not be found." >>"$LOG"
		stop failed
	}
	echo "Calling: cd \"$TEMP\"" >>"$LOG"
	cd "$TEMP" 2>>"$LOG" || {								# change into the directory that matches the unique CODE value
		echo "ERROR: The source code directory could not be entered." >>"$LOG"
		stop failed
	}
fi

if [ "$TYPE" = 'autoconf' ] && [ ! -e 'configure.ac' ]; then
	echo "ERROR: It does not appear that builder was called from within the source code directory." >>"$LOG"
	stop failed
elif [ "$TYPE" = 'autogen' ] && [ ! -e 'autogen.sh' ]; then
	echo "ERROR: It does not appear that builder was called from within the source code directory." >>"$LOG"
	stop failed
elif [ "$TYPE" = 'bootstrap' ] && [ ! -e 'CMakeLists.txt' ]; then				# this is just a wrapper for the 'cmake' build system
	echo "ERROR: It does not appear that builder was called from within the source code directory." >>"$LOG"
	stop failed
elif [ "$TYPE" = 'cmake' ] && [ ! -e 'CMakeLists.txt' ]; then
	echo "ERROR: It does not appear that builder was called from within the source code directory." >>"$LOG"
	stop failed
elif [ "$TYPE" = 'default' ] && [ ! -e 'configure' ] && [ ! -e 'Makefile' ]; then
	echo "ERROR: It does not appear that builder was called from within the source code directory." >>"$LOG"
	stop failed
elif [ "$TYPE" = 'scons' ] && [ ! -e 'SConstruct' ]; then
	echo "ERROR: It does not appear that builder was called from within the source code directory." >>"$LOG"
	stop failed
fi




# APPLY ANY PATCHES

if [ "$PATCH" ]; then
	echo -e "\nApplying software patches..." | tee -a "$LOG"

	if [ ! "$PASS" ]; then					# if we are not doing multi-pass, or we are on the first pass of a multi-pass, then...
		IFS=$'\n'
		for PATCH in $(ls -1 "${DIR_PROF}/patches" 2>/dev/null); do
			[ ! "$PATCH" ] && continue		# no clue why this is even having to be processed, but...

			echo -n "   ${PATCH##*/}: " | tee -a "$LOG"
			if [ -x "${DIR_PROF}/patches/${PATCH}" ]; then
				"${DIR_PROF}/patches/${PATCH}" || {
					echo "[failure]"
					echo "      [failure]" >>"$LOG"
					stop failed
				}
			else
				patch -p 0 < "${DIR_PROF}/patches/${PATCH}" >/dev/null 2>>"$LOG" || {
					echo "[failure]"
					echo "      [failure]" >>"$LOG"
					stop failed
				}
			fi
			echo "[success]" | tee -a "$LOG"
		done 2>/dev/null
	else
		IFS=$'\n'
		for PATCH in $(ls -1 "${DIR_PROF}/patches.${PASS}" 2>/dev/null); do
			[ ! "$PATCH" ] && continue		# no clue why this is even having to be processed, but...

			echo -n "   ${PATCH##*/}: " | tee -a "$LOG"
			if [ -x "${DIR_PROF}/patches.${PASS}/${PATCH}" ]; then
				"${DIR_PROF}/patches.${PASS}/${PATCH}" || {
					echo "[failure]"
					echo "      [failure]" >>"$LOG"
					stop failed
				}
			else
				patch -p 0 < "${DIR_PROF}/patches.${PASS}/${PATCH}" >/dev/null 2>>"$LOG" || {
					echo "[failure]"
					echo "      [failure]" >>"$LOG"
					stop failed
				}
			fi
			echo "[success]" | tee -a "$LOG"
		done 2>/dev/null
	fi
fi




# PERFORM THE ACTUAL COMPILE

[ ! "$PASS" ] && [ -x "${DIR_PROF}/pre.compile" ] && {		# execute any existing pre-compile script (for single-pass; multi-pass is next block)
	echo -e "\nExecuting the 'pre.compile' script..." | tee -a "$LOG"
	"${DIR_PROF}/pre.compile" 2>>"$LOG" || stop failed
}
[ "$PASS" ] && [ -x "${DIR_PROF}/pre.compile.${PASS}" ] && {
	echo -e "\nExecuting the 'pre.compile' script..." | tee -a "$LOG"
	"${DIR_PROF}/pre.compile.${PASS}" 2>>"$LOG" || stop failed
}

echo -e "\nGenerating the compile script..." | tee -a "$LOG"
echo "#!/bin/sh" >"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
# UPDATED 2026/02/12
#echo 'unset DIR_CONF DIR_DUMP DIR_INCL DIR_INST DIR_PROF DIR_MODS DIR_REPO DIR_TEMP DIR_XTRA' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"		# unset these variables set at the top of this script to not pollute the compile environment
echo 'unset DIR_CONF DIR_DUMP DIR_INST DIR_PROF DIR_REPO DIR_TEMP' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"		# unset these variables set at the top of this script to not pollute the compile environment
echo 'unset DIR_BIN DIR_ETC DIR_LIB DIR_SBIN DIR_SHARE DIR_VAR DIR_MARKERS DIR_SCRIPTS' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset DEP_MAKE_ALL' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset EXT_BLDR EXT_CODE EXT_DEPS EXT_HASH EXT_INFO EXT_LIST EXT_MAKE EXT_SOFT' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset OWN_USER OWN_GROUP' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset PRM_DIRS PRM_FILES PRM_EXECS' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset URL_CODE URL_REPO URL_INFO' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset SPM_ALL SPM_PACK SPM_UNLD' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset CPU SUDO' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo 'unset DEBUG' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo "$EXPORTS" | sed 's/^[ \t]*//' >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
echo >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
[ $CLEAN -eq 2 ] && { echo "make distclean >>\"$LOG\" 2>&1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"; }
[ $CLEAN -eq 1 ] && { echo "make clean >>\"$LOG\" 2>&1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"; }
[ $PROP -eq 1 ] && { echo "make mrproper >>\"$LOG\" 2>&1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"; }

TEMP=''
for DIR in CFG_BIN CFG_DATA CFG_DATAROOT CFG_DOC CFG_DVI CFG_HTML CFG_INCLUDE CFG_INFO CFG_LIB CFG_LIBEXEC CFG_LOCALE CFG_LOCALSTATE CFG_MAN CFG_OLDINCLUDE CFG_PDF CFG_PS CFG_SBIN CFG_SHAREDSTATE CFG_SYSCONFIG CFG_MISC; do
	[ "$(eval echo \$$DIR)" = '' ] && continue
	case $DIR in
		CFG_BIN) TEMP="$TEMP --bindir='$(eval echo \$$DIR)'" ;;
		CFG_DATA) TEMP="$TEMP --datadir='$(eval echo \$$DIR)'" ;;
		CFG_DATAROOT) TEMP="$TEMP --datarootdir='$(eval echo \$$DIR)'" ;;
		CFG_DOC) TEMP="$TEMP --docdir='$(eval echo \$$DIR)'" ;;
		CFG_DVI) TEMP="$TEMP --dvidir='$(eval echo \$$DIR)'" ;;
		CFG_HTML) TEMP="$TEMP --htmldir='$(eval echo \$$DIR)'" ;;
		CFG_INCLUDE) TEMP="$TEMP --includedir='$(eval echo \$$DIR)'" ;;
		CFG_INFO) TEMP="$TEMP --infodir='$(eval echo \$$DIR)'" ;;
		CFG_LIB) TEMP="$TEMP --libdir='$(eval echo \$$DIR)'" ;;
		CFG_LIBEXEC) TEMP="$TEMP --libexecdir='$(eval echo \$$DIR)'" ;;
		CFG_LOCALE) TEMP="$TEMP --localedir='$(eval echo \$$DIR)'" ;;
		CFG_LOCALSTATE) TEMP="$TEMP --localstatedir='$(eval echo \$$DIR)'" ;;
		CFG_MAN) TEMP="$TEMP --mandir='$(eval echo \$$DIR)'" ;;
		CFG_OLDINCLUDE) TEMP="$TEMP --oldincludedir='$(eval echo \$$DIR)'" ;;
		CFG_PDF) TEMP="$TEMP --pdfdir='$(eval echo \$$DIR)'" ;;
		CFG_PS) TEMP="$TEMP --psdir='$(eval echo \$$DIR)'" ;;
		CFG_SBIN) TEMP="$TEMP --sbindir='$(eval echo \$$DIR)'" ;;
		CFG_SHAREDSTATE) TEMP="$TEMP --sharedstatedir='$(eval echo \$$DIR)'" ;;
		CFG_SYSCONFIG) TEMP="$TEMP --sysconfdir='$(eval echo \$$DIR)'" ;;
		CFG_MISC) TEMP="$TEMP $(eval echo \$$DIR)" ;;
	esac
done

if [ "$TYPE" = 'autoconf' ]; then
	echo "autoreconf -fi >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	[ $CONF -eq 1 ] && { echo "./configure$TEMP $FLAG_CONF >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"; }
elif [ "$TYPE" = 'autogen' ]; then
	echo "./autogen.sh >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	[ $CONF -eq 1 ] && { echo "./configure$TEMP $FLAG_CONF >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"; }
elif [ "$TYPE" = 'bootstrap' ]; then
	[ -e bootstrap ] && echo "./bootstrap >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	[ -e bootstrap.sh ] && echo "./bootstrap.sh >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	[ $CONF -eq 1 ] && { echo "./configure$TEMP $FLAG_CONF >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"; }
elif [ "$TYPE" = 'cmake' ]; then
	echo "mkdir build_me >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "cd build_me >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "cmake $FLAG_CONF .. >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
elif [ "$TYPE" = 'custom' ]; then
# UPDATED 2026/02/12
#	echo "$COMPILE >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "$CUSTOM >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
elif [ "$TYPE" = 'default' ]; then
	[ $CONF -eq 1 ] && { echo "./configure$TEMP $FLAG_CONF >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"; }
elif [ "$TYPE" = 'scons' ]; then
	echo "scons $FLAG_CONF >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
fi

[ ! "$PASS" ] && [ -x "${DIR_PROF}/post.configure" ] && {	# execute any existing post-configure script (for single-pass; multi-pass is next block)
	echo "echo -e \"   Executing the 'post.configure' script...\" | tee -a \"$LOG\"" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "${DIR_PROF}/post.configure >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "echo -e \"   Proceeding with next steps of compile...\" | tee -a \"$LOG\"" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
}
[ "$PASS" ] && [ -x "${DIR_PROF}/post.configure.${PASS}" ] && {
	echo "echo -e \"   Executing the 'post.configure' script...\" | tee -a \"$LOG\"" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "${DIR_PROF}/post.configure.${PASS} >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "echo -e \"   Proceeding with next steps of compile...\" | tee -a \"$LOG\"" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
}

if [ "$TYPE" != 'scons' ]; then
	echo "make $FLAG_MAKE >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"		# NOTE: 'nice' should help prevent non-responding system crashes, and '-j' indicates to use all cores of a CPU during compiling
	[ $CHECK -eq 1 ] && echo "make check >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	[ $TEST -eq 1 ] && echo "make test >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
	echo "make install $FLAG_INST >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"	# install the newly compiled software in the temp packaging directory
elif [ "$TYPE" = 'scons' ]; then
	echo "scons install $FLAG_INST >>\"$LOG\" 2>&1 || exit 1" >>"${DIR_TEMP}/${NAME}.${EXT_MAKE}"
fi
chmod 775 "${DIR_TEMP}/${NAME}.${EXT_MAKE}"

echo -e "\nCompiling the software..." | tee -a "$LOG"
"${DIR_TEMP}/${NAME}.${EXT_MAKE}" || stop failed

echo -e "\nCopying in the 'include' files..." | tee -a "$LOG"
TEMP=''
for DIR in DIR_BIN DIR_ETC DIR_LIB DIR_SBIN DIR_SHARE DIR_VAR DIR_MARKERS DIR_SCRIPTS CFG_BIN CFG_DATA CFG_DATAROOT CFG_DOC CFG_DVI CFG_HTML CFG_INCLUDE CFG_INFO CFG_LIB CFG_LIBEXEC CFG_LOCALE CFG_LOCALSTATE CFG_MAN CFG_OLDINCLUDE CFG_PDF CFG_PS CFG_SBIN CFG_SHAREDSTATE CFG_SYSCONFIG CFG_MISC; do
	( [ "$(eval echo \$$DIR)" = '' ] || [ "$DIR" = 'DIR_MISC' ] ) && [ ! -e "${DIR_PROF}/include/${DIR}" ] && [ ! -e "${DIR_PROF}/include.${PASS}/${DIR}" ] && continue
	mkdir -p "${DIR_DUMP}/${NAME}/$(eval echo \$$DIR)" 2>>"$LOG"
	[ "$PASS" ] && cp -dpR "${DIR_PROF}/include.${PASS}/${DIR}/"* "${DIR_DUMP}/${NAME}/$(eval echo \$$DIR)" 2>>"$LOG"
	[ ! "$PASS" ] && cp -dpR "${DIR_PROF}/include/${DIR}/"* "${DIR_DUMP}/${NAME}/$(eval echo \$$DIR)" 2>>"$LOG"
done

[ ! "$PASS" ] && [ -x "${DIR_PROF}/post.compile" ] && {						# execute any existing post-compile script (for single-pass; multi-pass is next line)
	echo -e "\nExecuting the 'post.compile' script..." | tee -a "$LOG"
	"${DIR_PROF}/post.compile" 2>>"$LOG" || stop failed
}
[ "$PASS" ] && [ -x "${DIR_PROF}/post.compile.${PASS}" ] && {
	echo -e "\nExecuting the 'post.compile' script..." | tee -a "$LOG"
	"${DIR_PROF}/post.compile.${PASS}" 2>>"$LOG" || stop failed
}




# INSTALL TO SYSTEM IF COMPILE ONLY





# OPTIONALLY PACKAGE or INSTALL SOFTWARE

if [ ! "$COMPILE" ]; then										# if we are packaging, then call those routines
	package

elif [ "$COMPILE" ] && ( [ ! "$PASS" ] || [ $PASS -eq $(cat "${DIR_TEMP}/${NAME}.pass" | sed 's/|.*//') ] ); then			# otherwise we are doing a compile-only and need to install (if this is the only/last pass)
	echo -e "\nInstalling the compiled software..." | tee -a "$LOG"

	echo "Calling: cd \"$DIR_DUMP\"" >>"$LOG"
	cd "${DIR_DUMP}" 2>>"$LOG" || {								# change into the temp packaging directory
		echo "ERROR: The staging location directory (DIR_DUMP) could not be entered." >>"$LOG"
		stop failed
	}
	echo "Calling: $SUDO cp -dpR ./* /" >>"$LOG"
	eval $SUDO cp -dpR ./* / 2>>"$LOG" || {							# now copy the contents to the root of the file system
		echo "ERROR: The compiled software could not be installed." >>"$LOG"
		stop failed
	}
fi




# COMPILATION CLEANUP

if [ "$PASS" ] && [ -e "${DIR_PROF}/proper.${PASS}" ]; then					# if doing multi-pass -AND- automatic cleanup is requested on this pass...
	echo -e "\nCleaning the source code directory..." | tee -a "$LOG"

	if [ $PASS -eq $(cat "${DIR_TEMP}/${NAME}.pass" | sed 's/|.*//') ]; then		# if we are on the last pass, then...
		PASS=''										#   update the value so the next section won't be triggered (since its tracker file will be deleted below!)
		stop proper 0									#   cleanup whole environment
	else											# otherwise we are on one of the passes, so...
		stop clean 0									#   perform a partial cleanup
	fi
elif [ ! "$PASS" ] && [ -e "${DIR_PROF}/proper" ]; then						# if only doing a single pass -AND- automatic cleanup is requested...
	echo -e "\nCleaning the source code directory..." | tee -a "$LOG"

	stop proper 0
elif [ ! "$PASS" ] || [ $PASS -eq $(cat "${DIR_TEMP}/${NAME}.pass" | sed 's/|.*//') ]; then	# if only doing a single pass -OR- we are on the last pass, then...
	echo -en "\nWould you like to cleanup now that the software has been packaged? [Y/N] (N): "
	read
	[ "$REPLY" = 'Y' ] || [ "$REPLY" = 'y' ] && stop proper 0

	[ "$PASS" ] && PASS=''									# if we are on the last pass, update the value so the next section won't be triggered (since its tracker file just got deleted!)
fi




# OPTIONAL MULTI-PASS CALL

[ "$PASS" ] && {
	echo -e "\nStarting the next pass..." | tee -a "$LOG"

	TEMP='"$THIS" -A "$ARCH" -T "$TYPE"'
	[ "$WGET" != '' ] && TEMP="$TEMP -C $WGET"
	[ "$DIRS" ] && TEMP="$TEMP -D"
	#[ "$PASS" ] && TEMP="$TEMP -N '$PASS'"							  NOTE: we do NOT pass this value here since it will be picked up automatically at the top of the script
	[ "$PATCH" ] && TEMP="$TEMP -P"
	[ "$SKIP" ] && TEMP="$TEMP -F"
	[ "$TRIM" ] && TEMP="$TEMP -R \"$TRIM\""
	[ ! "$UNLOAD" ] && TEMP="$TEMP -U"

	cd "$CWDL"

	eval $TEMP "$NAME"
	exit 0
}

[ "$COMPILE" ] && echo -e "\nCongrats, the software has been compiled successfully!\n" | tee -a "$LOG"
[ ! "$COMPILE" ] && echo -e "\nCongrats, the software has been packaged successfully!\n" | tee -a "$LOG"

